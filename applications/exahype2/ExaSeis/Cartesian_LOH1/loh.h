//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#include "Abstractloh.h"
#include "riemannSolverLOH.h"
#include "VariableShortcuts_loh.h"
#include "tarch/logging/Log.h"
#include "generated/kernels/aderdg/linear/Kernels.h"

namespace examples {
  namespace exahype2 {
    namespace elastic {

      class loh;

    } // namespace elastic
  }   // namespace exahype2
} // namespace examples

class examples::exahype2::elastic::loh: public Abstractloh {
private:
  static tarch::logging::Log _log;

public:
  /**
   * Refinement criterion
   *
   * ExaHypE2 is guided by a maximum and minimum mesh (patch) size.
   * All (dynamic) AMR is constrained by these values, i.e. if your
   * mesh is coarser than the maximum mesh size, ExaHyPE 2 will
   * automatically refine. If you try to refine further than the
   * minimum mesh size, ExaHyPE 2 will ignore any refinement.
   *
   * Consequently, you are fine if you work with a regular mesh:
   * You set the maximum mesh size, and you leave everything else
   * to Peano 4/ExaHyPE 2. If you want to have an adaptive mesh,
   * use this routine to implement the refinement pattern.
   *
   * @param Q This is the (current) solution. The data is not set
   *  to a valid value throughout grid construction. That is: If
   *  t equals 0.0, you cannot assume that Q is properly initialised.
   *  Therefore, Q usually is only evaluated by dynamic AMR codes
   *  which make the solution follow
   */
  ::exahype2::RefinementCommand refinementCriterion(
    const double* __restrict__ Q, // Q[9+3]
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    double                                       t
  ) override;

  void initialCondition(
    double* __restrict__ Q, // Q[9+3]
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    const tarch::la::Vector<Dimensions, int>&    index,
    bool                                         gridIsConstructed
  ) override;

  void boundaryConditions(
    const double* __restrict__ Qinside, // Qinside[9+3]
    double* __restrict__ Qoutside,      // Qoutside[9+3]
    const tarch::la::Vector<Dimensions, double>& faceCentre,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    int                                          normal
  ) final override;

  void riemannSolver(
    double* const                                FL, // FL[9
    double* const                                FR, // FR[9
    const double* const                          QL, // QL[9+3]
    const double* const                          QR, // QR[9+3]
    const double                                 t,
    const double                                 dt,
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    const int                                    direction,
    bool                                         isBoundaryFace,
    int                                          faceIndex
  ) final override;

  double maxEigenvalue(
    const double* __restrict__ Q,
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal
  ) override;

  void flux(
    const double* __restrict__ Q, // Q[9+3]
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* __restrict__ F // F[9]
  ) override;

  void nonconservativeProduct(
    const double* __restrict__ Q,
    const double* __restrict__ deltaQ,
    const tarch::la::Vector<Dimensions, double>& faceCentre,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* __restrict__ BgradQ
  ) override;

  void multiplyMaterialParameterMatrix(
    const double* const                          Q,
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* const                                rhs
  ) override;

  void pointSource(
    const double* const Q, const double* const x, const double t, const double dt, double* const forceVector, int n
  ) override;

  void initPointSourceLocations(double sourceLocation[NumberOfPointSources][Dimensions]) override;
};
