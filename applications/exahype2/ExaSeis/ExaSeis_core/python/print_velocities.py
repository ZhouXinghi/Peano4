import matplotlib.pyplot as plt
import csv
import argparse

"Written by Marc Marot-Lassauzaie, I use this file to convert data from the .csv files generated by the parsers to somewhat legible plots"


"""
parse arguments to get details about which data should be extracted
"""

parser = argparse.ArgumentParser(
    description="Script to convert CSV generated by ExaHyPE2 executions into plots"
)
parser.add_argument(
    "--f",
    dest="file_name",
    type=str,
    required=True,
    help="Name of the file to be checked, does not need to contain '.csv'",
)
parser.add_argument(
    "--v", dest="v", type=int, default=0, help="Index of the variable to be plotted"
)
parser.add_argument(
    "--tmax",
    dest="t_max",
    type=float,
    default=None,
    help="Minimal time for which data should be plotted",
)
parser.add_argument(
    "--tmin",
    dest="t_min",
    type=float,
    default=0.01,
    help="Maximal time for which data should be plotted",
)
parser.add_argument(
    "--x",
    dest="x",
    type=float,
    default=7.348,
    help="x position of tracer which should be considered",
)
parser.add_argument(
    "--y",
    dest="y",
    type=float,
    default=None,
    help="y position of tracer which should be considered",
)
parser.add_argument(
    "--z",
    dest="z",
    type=float,
    default=None,
    help="z position of tracer which should be considered",
)

args = parser.parse_args()

"""
Extract some metadata about the positions of the various informations in the csv file.
These should always be the same but it's safer to check.
"""
try:
    csvData = list(csv.reader(open(args.file_name, "r"), delimiter=","))
except FileNotFoundError:
    try:
        csvData = list(csv.reader(open(args.file_name + ".csv", "r"), delimiter=","))
    except:
        print(
            "the file you have specified does not exist, please make sure that it does in the specified location"
        )
        exit()


timeIndex = csvData[0].index(" t")
vxIndex = csvData[0].index(" data ") + args.v
vyIndex = csvData[0].index(" data ") + args.v + 1
vzIndex = csvData[0].index(" data ") + args.v + 2
firstNumberIndex = csvData[0].index("number(0)")
secondNumberIndex = csvData[0].index(" number(1)")
if " x(2)" in csvData[0]:
    positionIndexes = [
        csvData[0].index(" x(0)"),
        csvData[0].index(" x(1)"),
        csvData[0].index(" x(2)"),
    ]
else:
    positionIndexes = [csvData[0].index(" x(0)"), csvData[0].index(" x(1)")]

"""
remove first row which should only contain metadata
"""
csvData = csvData[1:-1]


"""
Filter out only the data from tracers at the specified positions
"""


def position_check(a):
    value = True
    if args.t_min != None:
        value = value and float(a[timeIndex]) >= args.t_min
    if args.t_max != None:
        value = value and float(a[timeIndex]) <= args.t_max
    if args.x != None:
        value = value and float(a[positionIndexes[0]]) == args.x
    if args.y != None:
        value = value and float(a[positionIndexes[1]]) == args.y
    if args.z != None:
        value = value and float(a[positionIndexes[2]]) == args.z
    return value


csvData = [data for data in csvData if position_check(data)]


"""
Check how many tracers fit the filter by extracting the total numbers of number(0) and
number(1) tuples that exist with the filter.
The {number(0), number(1)} tuples should be unique for each tracer, therefore if there
exists more than one value for either of these after filtering, there are multiple
tracers that correspond to the filter.
In the same way if there are none, none of the tracers correspond to the filter.
"""
checkFirstIndexLength = set([data[firstNumberIndex] for data in csvData])
checksecondIndexLength = set([data[secondNumberIndex] for data in csvData])

if len(checkFirstIndexLength) == 0:
    raise Exception(
        "Specification was valid for none of the tracers, please check that a tracer exists at the specified position"
    )
elif len(checkFirstIndexLength) > 1 or len(checksecondIndexLength) > 1:
    raise Exception(
        "Specification was valid for more than one tracer, please clarify which you want through use of positions x, y and z"
    )


"""
Extract only the data from time and from the required value
"""

dt = []
vx = []
vy = []
vz = []

for row in csvData:
    dt.append(float(row[timeIndex]))
    vx.append(float(row[vxIndex]))
    vy.append(float(row[vyIndex]))
    vz.append(float(row[vzIndex]))

"""
Sort this data in the direction of increasing time
"""

dt, vx, vy, vz = zip(*sorted(zip(dt, vx, vy, vz)))

"""
Plot the data
"""

plt.plot(
    dt,
    vx,
    color="r",
    linestyle="dashed",
    marker="o",
    label="velocity in x-direction as a function of time",
)

plt.plot(
    dt,
    vy,
    color="g",
    linestyle="dashed",
    marker="o",
    label="velocity in y-direction as a function of time",
)

plt.plot(
    dt,
    vz,
    color="b",
    linestyle="dashed",
    marker="o",
    label="velocity in z-direction as a function of time",
)

plt.xticks(rotation=25)
plt.xlabel("t")
plt.ylabel("velocities")
plt.title("velocites as a function of time", fontsize=20)
plt.grid()
plt.legend()
plt.show()
