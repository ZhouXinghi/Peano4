//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#define ASAGI_NOMPI

#include "AbstractElasticSolver.h"
#include "VariableShortcuts_ElasticSolver.h"
#include "tarch/logging/Log.h"
#include "generated/kernels/aderdg/linear/Kernels.h"

#ifndef _TOP
#define _TOP 1
#endif

#define _CUSTOM_COORDINATES

// #include "../ExaSeis_core/Numerics/routines_curvilinear.h"
// #include "../ExaSeis_core/Numerics/pml.h"
// #include "../ExaSeis_core/Context/ContextCurvilinearPML.h"
// #include "../ExaSeis_core/Refinement/refinement.h"

#include "../ExaSeis_core/Context/ContextCurvilinearPML.h"
#include "../ExaSeis_core/Numerics/pml.h"
#include "../ExaSeis_core/Numerics/routines_curvilinear.h"
#include "../ExaSeis_core/Refinement/refinement.h"

namespace exahype2 {
  namespace elastic {

    class ElasticSolver;

  } // namespace elastic
} // namespace exahype2

class exahype2::elastic::ElasticSolver: public AbstractElasticSolver {
private:
  static tarch::logging::Log _log;

  VariableShortcuts s;

  ContextCurvilinear<VariableShortcuts, Order + 1>*                context;
  std::vector<Refinement::RefinementCriterion<VariableShortcuts>*> refinementCriteria;
  int                                                              pml_cell_width;
  double                                                           pml_alpha_const;
  double                                                           pml_alpha_scalar;
  double                                                           pml_rel_error;
  int                                                              pml_power;

public:
  ElasticSolver();

  /**
   * Refinement criterion
   *
   * ExaHypE2 is guided by a maximum and minimum mesh (patch) size.
   * All (dynamic) AMR is constrained by these values, i.e. if your
   * mesh is coarser than the maximum mesh size, ExaHyPE 2 will
   * automatically refine. If you try to refine further than the
   * minimum mesh size, ExaHyPE 2 will ignore any refinement.
   *
   * Consequently, you are fine if you work with a regular mesh:
   * You set the maximum mesh size, and you leave everything else
   * to Peano 4/ExaHyPE 2. If you want to have an adaptive mesh,
   * use this routine to implement the refinement pattern.
   *
   * @param Q This is the (current) solution. The data is not set
   *  to a valid value throughout grid construction. That is: If
   *  t equals 0.0, you cannot assume that Q is properly initialised.
   *  Therefore, Q usually is only evaluated by dynamic AMR codes
   *  which make the solution follow
   */
  ::exahype2::RefinementCommand refinementCriterion(
    const double* __restrict__ Q, // Q[36+19]
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    double                                       t
  ) override;

  void initialCondition(
    double* __restrict__ Q, // Q[36+19]
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    const tarch::la::Vector<Dimensions, int>&    index,
    bool                                         gridIsConstructed
  ) override;

  void boundaryConditions(
    const double* __restrict__ Qinside, // Qinside[36+19]
    double* __restrict__ Qoutside,      // Qoutside[36+19]
    const tarch::la::Vector<Dimensions, double>& faceCentre,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    int                                          normal
  ) final override;

  void riemannSolver(
    double* const                                FL, // FL[36
    double* const                                FR, // FR[36
    const double* const                          QL, // QL[36+19]
    const double* const                          QR, // QR[36+19]
    const double                                 t,
    const double                                 dt,
    const tarch::la::Vector<Dimensions, double>& x,
    const tarch::la::Vector<Dimensions, double>& h,
    const int                                    direction,
    bool                                         isBoundaryFace,
    int                                          faceIndex
  ) final override;

  double maxEigenvalue(
    const double* __restrict__ Q,
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal
  ) override;

  void flux(
    const double* __restrict__ Q, // Q[36+19]
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* __restrict__ F // F[36]
  ) override;

  void nonconservativeProduct(
    const double* __restrict__ Q,
    const double* __restrict__ deltaQ,
    const tarch::la::Vector<Dimensions, double>& faceCentre,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* __restrict__ BgradQ
  ) override;

  void algebraicSource(const tarch::la::Vector<Dimensions, double>& x, double t, const double* const Q, double* S)
    override;

  void multiplyMaterialParameterMatrix(
    const double* const                          Q,
    const tarch::la::Vector<Dimensions, double>& volumeX,
    const tarch::la::Vector<Dimensions, double>& volumeH,
    double                                       t,
    double                                       dt,
    int                                          normal,
    double* const                                rhs
  ) override;

  void pointSource(
    const double* const Q, const double* const x, const double t, const double dt, double* const forceVector, int n
  ) override;

  void initPointSourceLocations(double sourceLocation[NumberOfPointSources][Dimensions]) override;
};
