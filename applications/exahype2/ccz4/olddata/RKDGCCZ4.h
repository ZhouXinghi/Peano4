//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#include "AbstractRKDGCCZ4.h"
#include "tarch/logging/Log.h"

#include <cstring>
#include "InitialValues.h"

#include "CCZ4Kernels.h"
namespace applications {namespace exahype2 {namespace ccz4 {
  class RKDGCCZ4;

}}}


class applications::exahype2::ccz4::RKDGCCZ4: public AbstractRKDGCCZ4 {
  private:
    static tarch::logging::Log   _log;

  public:
    RKDGCCZ4();  
    /**
     * Refinement criterion
     *
     * ExaHypE2 is guided by a maximum and minimum mesh (patch) size.
     * All (dynamic) AMR is constrained by these values, i.e. if your
     * mesh is coarser than the maximum mesh size, ExaHyPE 2 will
     * automatically refine. If you try to refine further than the
     * minimum mesh size, ExaHyPE 2 will ignore any refinement.
     *
     * Consequently, you are fine if you work with a regular mesh:
     * You set the maximum mesh size, and you leave everything else
     * to Peano 4/ExaHyPE 2. If you want to have an adaptive mesh,
     * use this routine to implement the refinement pattern.
     *
     * @param Q This is the (current) solution. The data is not set
     *  to a valid value throughout grid construction. That is: If
     *  t equals 0.0, you cannot assume that Q is properly initialised.
     *  Therefore, Q usually is only evaluated by dynamic AMR codes
     *  which make the solution follow
     */
    ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__                  Q,    // Q[59+0],
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<Dimensions,double>&  h,
      double                                       t
    ) override;
    
#ifdef IncludeTwoPunctures
    void prepare(TP::TwoPunctures* tp); 
#endif

    
    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<Dimensions,double>&  h,
      const tarch::la::Vector<Dimensions,int>&     index,
      bool                                         gridIsConstructed
    ) override;
    

    
    
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[59+0]
      double * __restrict__ Qoutside, // Qoutside[59+0]
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      int                                          normal
    )  override;
    

    
  public:
    
    void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    ) override;
    

    

    
    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__ Q, // Q[59+0],
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      int                                          normal
    ) override;
    


    
     
     
    
    virtual void nonconservativeProduct(
      const double * __restrict__                  Q, // Q[59+0],
      const double * __restrict__                  dQdx, // [59+0]
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__                        BgradQ // BgradQ[59]
    ) override;
    
    
   
    

   
    

    


    
     
   
        
};


