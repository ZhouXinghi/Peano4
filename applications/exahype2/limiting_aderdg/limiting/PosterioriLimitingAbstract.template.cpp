// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#include "{{CLASSNAME}}.h"

#include <algorithm>

#include "Constants.h"

#include "tarch/multicore/Lock.h"

#include "repositories/SolverRepository.h"

tarch::logging::Log   {{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}::_log( "{{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}" );

{{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}():
  _solverState(SolverState::GridConstruction),
  _cellUpdates(0),
  _numberOfTroubledCellsThisTimeStep(0) {

  generated::kernels::limiter::Quadrature<double>::initQuadratureNodesAndWeights();

  {{CONSTRUCTOR_IMPLEMENTATION}}
  
}

{{NAMESPACE | join("::")}}::{{CLASSNAME}}::~{{CLASSNAME}}(){

  generated::kernels::limiter::Quadrature<double>::freeQuadratureNodesAndWeights();

}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinTimeStamp();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxTimeStamp();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinTimeStepSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinTimeStepSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxTimeStepSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxTimeStepSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxMeshSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxMeshSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinMeshSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinMeshSize();
}


{{NAMESPACE | join("::")}}::{{CLASSNAME}}::SolverState {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getSolverState() const {
  return _solverState;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startGridConstructionStep() {
  assertion( _solverState == SolverState::GridConstruction );
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishGridConstructionStep() {
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startGridInitialisationStep() {
  _solverState = SolverState::GridInitialisation;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishGridInitialisationStep() {

}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::suspendSolversForOneGridSweep() {
  _solverState = SolverState::Suspended;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startTimeStep(
  double globalMinTimeStamp,
  double globalMaxTimeStamp,
  double globalMinTimeStepSize,
  double globalMaxTimeStepSize
) {
  switch (_solverState) {
    case SolverState::GridConstruction:
      _solverState = SolverState::GridInitialisation;
      break;
    case SolverState::GridInitialisation:
    case SolverState::Suspended:
    case SolverState::Plotting:
    case SolverState::RegularSolver:
      _solverState = (_numberOfTroubledCellsThisTimeStep == 0 ?
        SolverState::RegularSolver : SolverState::LimiterStatusSpreadingToNeighbours);
      break;
    case SolverState::LimiterStatusSpreadingToNeighbours:
      _solverState = SolverState::LimiterStatusSpreadingToSecondNeighbours;
      break;
    case SolverState::LimiterStatusSpreadingToSecondNeighbours:
      _solverState = SolverState::LimiterSolver;
      break;
    case SolverState::LimiterSolver:
      _solverState = SolverState::RegularSolver;
      break;
  }

  if (_solverState==SolverState::RegularSolver) {

    _cellUpdates    = 0;
    _numberOfTroubledCellsThisTimeStep = 0;

  }

  {{START_TIME_STEP_IMPLEMENTATION}}


  if (_solverState==SolverState::RegularSolver) {
    repositories::{{LIMITER_SOLVER_INSTANCE}}.suspendSolversForOneGridSweep();

    _cellUpdates    = 0;
    _numberOfTroubledCellsThisTimeStep = 0;
  }

  if (_solverState==SolverState::LimiterSolver) {
    repositories::{{REGULAR_SOLVER_INSTANCE}}.suspendSolversForOneGridSweep();
  }

  if(_solverState==SolverState::LimiterStatusSpreadingToNeighbours
    or _solverState==SolverState::LimiterStatusSpreadingToSecondNeighbours
    ){
    repositories::{{LIMITER_SOLVER_INSTANCE}}.suspendSolversForOneGridSweep();
    repositories::{{REGULAR_SOLVER_INSTANCE}}.suspendSolversForOneGridSweep();
  }

  if (
    tarch::mpi::Rank::getInstance().isGlobalMaster()
//    and ( _solverState==SolverState::RegularSolver or _solverState==SolverState::LimiterSolver )
  ) {

    logInfo( "startTimeStep(...)", "LIMITING SOLVER" );
    logInfo( "startTimeStep(...)", "phase " + toString(_solverState) );
    logInfo( "startTimeStep()", "total number of troubled cells: = " << _numberOfTroubledCellsThisTimeStep );
    logInfo( "startTimeStep(...)", "LIMITING SOLVER\n" );

    // if(_numberOfTroubledCellsThisTimeStep>0){
    //     ::exahype2::triggerNonCriticalAssertion( __FILE__, __LINE__, "_numberOfTroubledCellsThisTimeStep>0", "_numberOfTroubledCellsThisTimeStep: " + std::to_string(_numberOfTroubledCellsThisTimeStep) );
    // }
  }


}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishTimeStep() {
	if ( isLastGridSweepOfTimeStep() ) {

  #ifdef Parallel

  int newCellUpdates = _cellUpdates;
  int newNumberOfTroubleCells = _numberOfTroubledCellsThisTimeStep;

  tarch::mpi::Rank::getInstance().allReduce(
      &newCellUpdates,
      &_cellUpdates,
      1, MPI_INT,
      MPI_SUM,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

  tarch::mpi::Rank::getInstance().allReduce(
      &newNumberOfTroubleCells,
      &_numberOfTroubledCellsThisTimeStep,
      1, MPI_INT,
      MPI_SUM,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );
  #endif

  {{FINISH_TIME_STEP_IMPLEMENTATION}}

  }
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startPlottingStep(
  double globalMinTimeStamp,
  double globalMaxTimeStamp,
  double globalMinTimeStepSize,
  double globalMaxTimeStepSize
) {
  assertion( mayPlot() );
  _solverState = SolverState::Plotting;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishPlottingStep() {
}


std::string {{NAMESPACE | join("::")}}::{{CLASSNAME}}::toString(SolverState state) {
  switch (state) {
    case SolverState::GridConstruction:
      return "grid-construction";
    case SolverState::GridInitialisation:
      return "grid-initialisation";
    case SolverState::RegularSolver:
      return "regular (non-limiting) solver";
    case SolverState::LimiterStatusSpreadingToNeighbours:
			return "limiter status spreading to neighbours";
    case SolverState::LimiterStatusSpreadingToSecondNeighbours:
			return "limiter status spreading to second neighbours";
    case SolverState::LimiterSolver:
			return "limiting solver";
    case SolverState::Plotting:
      return "plotting";
    case SolverState::Suspended:
			return "suspended";
  }
  return "<undef>";
}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::mayPlot() const {
  return
    (
        (
          _solverState==SolverState::GridInitialisation
        or
          _solverState==SolverState::RegularSolver
          and repositories::{{REGULAR_SOLVER_INSTANCE}}.mayPlot()
          and _numberOfTroubledCellsThisTimeStep==0
        )
      or
        (
          _solverState==SolverState::LimiterSolver and
          repositories::{{LIMITER_SOLVER_INSTANCE}}.mayPlot()
        )
    );
}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::isFirstGridSweepOfTimeStep() const {
  return (
    ( _solverState==SolverState::RegularSolver and repositories::{{REGULAR_SOLVER_INSTANCE}}.isFirstGridSweepOfTimeStep() )
    or
    ( _solverState==SolverState::LimiterSolver and repositories::{{LIMITER_SOLVER_INSTANCE}}.isFirstGridSweepOfTimeStep() )
  );

}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::isLastGridSweepOfTimeStep() const {
  return (
    ( _solverState==SolverState::RegularSolver and repositories::{{REGULAR_SOLVER_INSTANCE}}.isLastGridSweepOfTimeStep() )
    or
    ( _solverState==SolverState::LimiterSolver and repositories::{{LIMITER_SOLVER_INSTANCE}}.isLastGridSweepOfTimeStep() )
  );
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startSimulation() {

}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishSimulation() {

}


void {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::addTroubledCell(){
  _numberOfTroubledCellsThisTimeStep += 1;
}
int {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::getNumberOfTroubledCells() const {
  return _numberOfTroubledCellsThisTimeStep;  
}


{% if ADMISSIBILITY_IMPLEMENTATION!="<empty>" and ADMISSIBILITY_IMPLEMENTATION!="<user-defined>" %}
bool {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::isPhysicallyAdmissible(
  const double* const                         Q,
  const tarch::la::Vector<Dimensions,double>& x,
  const tarch::la::Vector<Dimensions,double>& h,
  const double timeStamp
){

  {% if ADMISSIBILITY_IMPLEMENTATION!="<none>"%}
  {{ADMISSIBILITY_IMPLEMENTATION}}
  {% else %}
  return true;
  {% endif %}

}
{% endif %}


{{SOLVER_USER_DEFINITIONS}}
