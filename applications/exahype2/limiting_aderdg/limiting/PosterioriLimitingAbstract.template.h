// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once

#include "exahype2/Solver.h"
#include "exahype2/NonCriticalAssertions.h"

#include "tarch/la/Vector.h"
#include "tarch/logging/Log.h"
#include "tarch/mpi/Rank.h"
#include "tarch/multicore/BooleanSemaphore.h"

#include "peano4/utils/Globals.h"

#include "Constants.h"

#include "generated/kernels/limiter/fv/Quadrature.h"

{{SOLVER_INCLUDES}}

{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}

class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public ::exahype2::Solver {
  public:
    /**
     * This is a "fake" enum, i.e. we do not use it to distinguish different
     * variants. Instead, we use it as a fix that allows us to "overload"
     * operations:
     *
     * In C++ you cannot overload w.r.t. static. We however need functions which
     * exist twice in ExaHyPE: Once as standard (virtual) member functions and
     * once at static version which an be offloaded to a GPU as it does not
     * have a state. Both function variants, in theory, have the same signature
     * but if they had, a compiler could not distinguish them. So I use this
     * enum for the GPU version.
     *
     * If you create a solver without GPU support, this enum will not be used.
     * It is however always created. Once you write a GPU version and then compile
     * without GPU support, you will thus still be able to have all your GPU
     * function variants, and you don't have to work with ifdefs.
     */
    enum class Offloadable {
      Yes
    };

    enum class SolverState {
      GridConstruction,
      GridInitialisation,
      RegularSolver,
      LimiterStatusSpreadingToNeighbours,
      LimiterStatusSpreadingToSecondNeighbours,
      LimiterSolver,
      Plotting,
      Suspended
    };

    static std::string toString(SolverState);

    {{CLASSNAME}}();
    ~{{CLASSNAME}}();

    SolverState  getSolverState() const;

    double getMinTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;
    double getMaxTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;
    double getMinTimeStepSize() const final;
    double getMaxTimeStepSize() const final;

    virtual double getMaxMeshSize() const override final;
    virtual double getMinMeshSize() const override final;

    //TODO: link these to the max and min of the other solvers
    static constexpr double MaxAdmissibleCellH  = 1000.;
    static constexpr double MinAdmissibleCellH  = 0.;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startGridConstructionStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishGridConstructionStep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startGridInitialisationStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishGridInitialisationStep() override;


    virtual void suspendSolversForOneGridSweep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishTimeStep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startPlottingStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishPlottingStep() override;

    /**
     * Always holds.
     */
    virtual bool mayPlot() const override;

    /**
     * This predicate is always true, as we work with a single-sweep
     * implementation, i.e. each grid sweep realises one time step.
     */
    bool isFirstGridSweepOfTimeStep() const;
    bool isLastGridSweepOfTimeStep() const;

    /**
     * Feel free to overwrite in user code, but ensure the superclass
     * implementation is still invoked, too.
     */
    virtual void startSimulation() override;

    /**
     * Feel free to overwrite in user code, but ensure the superclass
     * implementation is still invoked, too.
     */
    virtual void finishSimulation() override;


    public:
        static constexpr int NumberOfDMPObservables    = {{NUMBER_OF_DMP_OBSERVABLES}};
        static constexpr double RelaxationParameter    = {{DMP_RELAXATION_PARAMETER}};
        static constexpr double DifferencesScaling     = {{DMP_DIFFERENCES_SCALING}};

        /**
        * Inform the solver about a cell being troubled, meaning its value
        * needs to be recomputed and the solver cannot move on to the next
        * timestep until this is done.
        */
        void addTroubledCell();
        int getNumberOfTroubledCells() const;

        /**
        * Default implementation. Please overwrite.
        *
        * See superclass for function's semantics.
        */
        void mapDiscreteMaximumPrincipleObservables(double* const observables, const double* const Q) const {
          if (NumberOfDMPObservables>0) {
            std::copy_n(Q,NumberOfDMPObservables,observables);
          }
        }

        /**
        * Default implementation. Please overwrite.
        *
        * See superclass for function's semantics.
        */
        double getDiscreteMaximumPrincipleRelaxationParameter(
            const double& specifiedRelaxationParameter,
            const int&    observable,
            const double& localMin,
            const double& localMax,
            const double& boundaryMinPerObservable,
            const double& previousMax) const {
          return specifiedRelaxationParameter;
        }

{% if ADMISSIBILITY_IMPLEMENTATION!="<none>" %}
    virtual bool isPhysicallyAdmissible(
        const double* const                         Q,
        const tarch::la::Vector<Dimensions,double>& x,
        const tarch::la::Vector<Dimensions,double>& h,
        const double timeStamp) {% if ADMISSIBILITY_IMPLEMENTATION=="<user-defined>" %} = 0 {% else %} final {% endif %};
{% endif %}



  protected:
    static tarch::logging::Log  _log;

    SolverState  _solverState;

    int        _cellUpdates;

    int        _numberOfTroubledCellsThisTimeStep;

    tarch::multicore::BooleanSemaphore  _semaphore;


  {{SOLVER_USER_DECLARATIONS}}
};


