// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#include "{{CLASSNAME}}.h"

#include <algorithm>

#include "Constants.h"

#include "tarch/multicore/Lock.h"

#include "repositories/SolverRepository.h"

tarch::logging::Log   {{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}::_log( "{{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}" );

{{NAMESPACE | join("::")}}::{{CLASSNAME}}::{{CLASSNAME}}():
  _solverState(SolverState::GridConstruction),
  _cellUpdates(0),
  _totalNumberOfTroubledCells(0) {

  generated::kernels::limiter::Quadrature<double>::initQuadratureNodesAndWeights();

  {{CONSTRUCTOR_IMPLEMENTATION}}
  
}

{{NAMESPACE | join("::")}}::{{CLASSNAME}}::~{{CLASSNAME}}(){

  generated::kernels::limiter::Quadrature<double>::freeQuadratureNodesAndWeights();

}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinTimeStamp();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxTimeStamp();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinTimeStepSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinTimeStepSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxTimeStepSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxTimeStepSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMaxMeshSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMaxMeshSize();
}


double {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getMinMeshSize() const {
  return repositories::{{REGULAR_SOLVER_INSTANCE}}.getMinMeshSize();
}


{{NAMESPACE | join("::")}}::{{CLASSNAME}}::SolverState {{NAMESPACE | join("::")}}::{{CLASSNAME}}::getSolverState() const {
  return _solverState;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startGridConstructionStep() {
  assertion( _solverState == SolverState::GridConstruction );
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishGridConstructionStep() {
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startGridInitialisationStep() {
  _solverState = SolverState::GridInitialisation;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishGridInitialisationStep() {

}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::suspendSolversForOneGridSweep() {
  _solverState = SolverState::Suspended;
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startTimeStep(
  double globalMinTimeStamp,
  double globalMaxTimeStamp,
  double globalMinTimeStepSize,
  double globalMaxTimeStepSize
) {
  switch (_solverState) {
    case SolverState::GridConstruction:
      _solverState = SolverState::GridInitialisation;
      break;
    case SolverState::GridInitialisation:
    case SolverState::PlottingAfterGridInitialisation:
      _solverState = SolverState::LimiterStatusSpreadingToNeighbours;
      break;
    case SolverState::LimiterStatusSpreadingToNeighbours:
    case SolverState::TimeStepping:
    case SolverState::Plotting:
    case SolverState::Suspended:
      _solverState = SolverState::TimeStepping;
      break;
  }

  {{START_TIME_STEP_IMPLEMENTATION}}

  if(_solverState==SolverState::LimiterStatusSpreadingToNeighbours){
      repositories::InstanceOfaderSolver.suspendSolversForOneGridSweep();
      repositories::InstanceOffvSolver.suspendSolversForOneGridSweep();
  }

  if (
    tarch::mpi::Rank::getInstance().isGlobalMaster()
  ) {

    logInfo( "startTimeStep(...)", "LIMITING SOLVER" );
    logInfo( "startTimeStep(...)", "phase " + toString(_solverState) );
    logInfo( "startTimeStep()", "total number of troubled cells: = " << _totalNumberOfTroubledCells );
    logInfo( "startTimeStep(...)", "LIMITING SOLVER\n" );

    // if(_numberOfTroubledCellsThisTimeStep>0){
    //     ::exahype2::triggerNonCriticalAssertion( __FILE__, __LINE__, "_numberOfTroubledCellsThisTimeStep>0", "_numberOfTroubledCellsThisTimeStep: " + std::to_string(_numberOfTroubledCellsThisTimeStep) );
    // }
  }


}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishTimeStep() {
	if ( isLastGridSweepOfTimeStep() ) {

  #ifdef Parallel

  int newCellUpdates = _cellUpdates;

  tarch::mpi::Rank::getInstance().allReduce(
      &newCellUpdates,
      &_cellUpdates,
      1, MPI_INT,
      MPI_SUM,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

  if(_solverState==LimiterStatusSpreadingToNeighbours){
    int newNumberOfTroubleCells = _totalNumberOfTroubledCells;
    tarch::mpi::Rank::getInstance().allReduce(
        &newNumberOfTroubleCells,
        &_totalNumberOfTroubledCells,
        1, MPI_INT,
        MPI_SUM,
        [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
        );
  }

  #endif

  {{FINISH_TIME_STEP_IMPLEMENTATION}}

  }
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startPlottingStep(
  double globalMinTimeStamp,
  double globalMaxTimeStamp,
  double globalMinTimeStepSize,
  double globalMaxTimeStepSize
) {
  if ( _solverState==SolverState::GridInitialisation) {
    _solverState = SolverState::PlottingAfterGridInitialisation;
  }
  else {
    _solverState = SolverState::Plotting;
  }
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishPlottingStep() {
}


std::string {{NAMESPACE | join("::")}}::{{CLASSNAME}}::toString(SolverState state) {
  switch (state) {
    case SolverState::GridConstruction:
      return "grid-construction";
    case SolverState::GridInitialisation:
      return "grid-initialisation";
    case SolverState::PlottingAfterGridInitialisation:
      return "plotting-after-grid-initialisation";
    case SolverState::LimiterStatusSpreadingToNeighbours:
			return "limiter status spreading to neighbours";
    case SolverState::TimeStepping:
			return "timestepping";
    case SolverState::Plotting:
      return "plotting";
    case SolverState::Suspended:
			return "suspended";
  }
  return "<undef>";
}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::mayPlot() const {
  return _solverState!=SolverState::LimiterStatusSpreadingToNeighbours;
}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::isFirstGridSweepOfTimeStep() const {
  return (
    _solverState!=SolverState::LimiterStatusSpreadingToNeighbours
    and
    repositories::{{REGULAR_SOLVER_INSTANCE}}.isFirstGridSweepOfTimeStep()
    and
    repositories::{{LIMITER_SOLVER_INSTANCE}}.isFirstGridSweepOfTimeStep()
  );

}


bool {{NAMESPACE | join("::")}}::{{CLASSNAME}}::isLastGridSweepOfTimeStep() const {
  return (
    _solverState!=SolverState::LimiterStatusSpreadingToNeighbours
    and
    repositories::{{REGULAR_SOLVER_INSTANCE}}.isLastGridSweepOfTimeStep()
    and
    repositories::{{LIMITER_SOLVER_INSTANCE}}.isLastGridSweepOfTimeStep()
  );
}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::startSimulation() {

}


void {{NAMESPACE | join("::")}}::{{CLASSNAME}}::finishSimulation() {

}


void {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::addTroubledCell(){
  _totalNumberOfTroubledCells += 1;
}
int {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::getNumberOfTroubledCells() const {
  return _totalNumberOfTroubledCells;  
}


{% if ADMISSIBILITY_IMPLEMENTATION!="<empty>" and ADMISSIBILITY_IMPLEMENTATION!="<user-defined>" %}
bool {{FULL_QUALIFIED_NAMESPACE}}::{{CLASSNAME}}::isPhysicallyAdmissible(
  const double* const                         Q,
  const tarch::la::Vector<Dimensions,double>& x,
  const tarch::la::Vector<Dimensions,double>& h,
  const double timeStamp
){

  {% if ADMISSIBILITY_IMPLEMENTATION!="<none>"%}
  {{ADMISSIBILITY_IMPLEMENTATION}}
  {% else %}
  return true;
  {% endif %}

}
{% endif %}


{{SOLVER_USER_DEFINITIONS}}
