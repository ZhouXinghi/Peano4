//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#include "AbstractCCZ4.h"
#include "tarch/logging/Log.h"


#include <cstring>
#include "InitialValues.h"

#include "CCZ4Kernels.h"


namespace benchmarks {
  namespace exahype2 {
    namespace ccz4 {
      class CCZ4;
    }
  }
}


class benchmarks::exahype2::ccz4::CCZ4: public AbstractCCZ4 {
  private:
    static tarch::logging::Log   _log;

  public:
    CCZ4();
    
    /**
     * Refinement criterion
     *
     *
     * ## Single black hole, low refinement (CCZ4ReSwi==2)
     *
     *
     * ## Single black hole (CCZ4ReSwi==6)
     *
     * Single black hole setup with two refinement levels such that the finest
     * volume is the same size as it is in the regular grid tests. We use two
     * level of refinement which arrange around the area of interest. Within
     * the innermost radius of 3.5, we enforce a mesh size of 0.04, while we
     * have a compute cell size of at least 0.15 within the radius of 5. For
     * everything futher away than 5 from the centre, we stick to the maximum
     * mesh size.
     *
     * We use the setup with
     *
     *         python3 ccz4.py -impl fd4-rk1-adaptive -s two-punctures -maxh 0.4 -minh 0.04 -ps 6 -plt 0.5 -et 0.5 -exn test --domain_r 9.0 --ReSwi 7 -cfl 0.1 -outdir ./ --KOSigma 8.0
     *
     * in standard benchmarks.
     *
     * Alternative settings would have been
     *
     *        double Radius[NumberOfRefinementLayers] = {5.0, 3.0};
     *        double MaxH[NumberOfRefinementLayers]   = {0.3, 0.15};
     *
     *
     * @param Q This is the (current) solution. The data is not set
     *  to a valid value throughout grid construction. That is: If
     *  t equals 0.0, you cannot assume that Q is properly initialised.
     *  Therefore, Q usually is only evaluated by dynamic AMR codes
     *  which make the solution follow
     */
    ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__ Q, // Q[59+0],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    ) override;
    
#ifdef IncludeTwoPunctures
    void prepare(TP::TwoPunctures* tp); 
#endif

    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      bool                                         gridIsConstructed
    ) override;
    

    
    
    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[59+0]
      double * __restrict__ Qoutside, // Qoutside[59+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  override;
    

    
  public:
    
    void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    ) override;
    

    
    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__ Q, // Q[59+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal
    ) override;
    


    
     
     
    
    virtual void nonconservativeProduct(
      const double * __restrict__ Q, // Q[59+0],
      const double * __restrict__             deltaQ, // [59+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__ BgradQ // BgradQ[59]
    ) override;
    
    
   
    
    /**
     * To obtain the best performance, I recommend to man inline command to 
     * this signature and to copy the implementation into the header. So it would
     * read 
     *
     * static inline void sourceTerm( ... ) {
     *  code here
     * }
     *
     * The GPU offloading requires static functions. As we cannot overload the
     * original (virtual) function with a static alternative, we do the
     * TBB trick and overload by adding an additional enum. It has no semantics
     * but helps the compiler to distinguish the different function variants.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void sourceTerm(
       const double * __restrict__ Q,
       const tarch::la::Vector<Dimensions,double>&  volumeCentre,
       const tarch::la::Vector<Dimensions,double>&  volumeH,
       double                                       t,
       double                                       dt,
       double * __restrict__ S,
       ::exahype2::Solver::Offloadable
     ) {
      memset(S, 0, NumberOfUnknowns*sizeof(double));
      applications::exahype2::ccz4::source(S,Q, CCZ4LapseType, CCZ4ds, CCZ4c, CCZ4e, CCZ4f, CCZ4bs, CCZ4sk, CCZ4xi, CCZ4itau, CCZ4eta, CCZ4k1, CCZ4k2, CCZ4k3, CCZ4SO);
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
    


    
    /**
     * To obtain the best performance, I recommend to man inline command to 
     * this signature and to copy the implementation into the header. So it would
     * read 
     *
     * static inline double maxEigenvalue( ... ) {
     *  code here
     * }
     *
     * The GPU offloading requires static functions. As we cannot overload the
     * original (virtual) function with a static alternative, we do the
     * TBB trick and overload by adding an additional enum. It has no semantics
     * but helps the compiler to distinguish the different function variants.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod double maxEigenvalue(
      const double * __restrict__ Q, // Q[59+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      ::exahype2::Solver::Offloadable
    ) {
      const double np = 1.0;
      #if defined(CCZ4EINSTEIN)
      const double qmin = std::min({Q[0],Q[3],Q[5]});
      const double alpha = std::max({1.0, Q[16]}) * std::max({1.0, pow(Q[54],1.0/np)}) / std::sqrt(qmin);
      #else
      const double alpha = 1.0;
      #endif

      constexpr double sqrtwo = 1.4142135623730951;
      // NOTE parameters are stored in abstract superclass
      const double tempA = alpha * std::max({sqrtwo, CCZ4e, CCZ4ds, CCZ4GLMc/alpha, CCZ4GLMd/alpha});
      const double tempB = Q[17+normal];//DOT_PRODUCT(Q(18:20),nv(:))
      double tem = std::max({1.0, std::abs(-tempA-tempB), std::abs(tempA-tempB)});
      bool flag = false;
      return tem;
    }

    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
    


    
     
   
    
    /**
     * To obtain the best performance, I recommend to man inline command to 
     * this signature and to copy the implementation into the header. So it would
     * read 
     *
     * static inline void nonconservativeProduct( ... ) {
     *  code here
     * }
     *
     * The GPU offloading requires static functions. As we cannot overload the
     * original (virtual) function with a static alternative, we do the
     * TBB trick and overload by adding an additional enum. It has no semantics
     * but helps the compiler to distinguish the different function variants.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void nonconservativeProduct(
      const double * __restrict__                  Q,         // Q[5+0],
      const double * __restrict__                  deltaQ,    // [5+0]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__                        BgradQ,     // BgradQ[5]
      ::exahype2::Solver::Offloadable
    );
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
        
};


