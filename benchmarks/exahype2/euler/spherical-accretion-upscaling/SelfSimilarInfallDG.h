//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#include "AbstractSelfSimilarInfallDG.h"

#include "tarch/logging/Log.h"
#include "tarch/accelerator/accelerator.h"

#include "spherical-accretion/MassAccumulator.h"
#include "spherical-accretion/GravityModel.h"

#include "EulerKernels.h"


namespace benchmarks {namespace exahype2 {namespace euler {namespace sphericalaccretionupscaling {
  class SelfSimilarInfallDG;

}}}}


class benchmarks::exahype2::euler::sphericalaccretionupscaling::SelfSimilarInfallDG: public AbstractSelfSimilarInfallDG {
  private:
    static tarch::logging::Log   _log;

    /**
     * Use class from application folders.
     */
    ::applications::exahype2::euler::sphericalaccretion::MassAccumulator  _accumulator;

    /**
     * After each time step, we backup the total mass in this static variable.
     * It has to be static, as we want to use it in stateless terms later on.
     */
    static double TotalMassInPreviousTimeStep;
  public:
    static constexpr double BaseDensity      = 0.1;
    static constexpr double Gamma            = 5.0/3.0;
    static constexpr double pInitial         = 1e-6;
    static constexpr double aInitial         = 0.001;
    static constexpr double AdditionalMass   = 0.15;
    static constexpr double InitialTopHatRadius = 0.05;

    SelfSimilarInfallDG();

    /**
     * Add mass corresponding to one degree of freedom. This is the value in
     * this dof (as we work with a Lagrangian formulation) times the quadrature
     * weight for this point, i.e. times the integral over the shape function.
     */
    void addDensity(
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<3,double>&           cellSize,
      const tarch::la::Vector<3,int>&              index,
      double                                       density
    );

    
    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<Dimensions,double>&  h,
      const tarch::la::Vector<Dimensions,int>&     index,
      bool                                         gridIsConstructed
    ) override;
    

    virtual void boundaryConditions(
      const double * __restrict__ Qinside, // Qinside[5+0]
      double * __restrict__ Qoutside, // Qoutside[5+0]
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      int                                          normal
    )  override;
    

    void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    ) override;
    

    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. All parameters are in.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__                  Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      int                                          normal
    ) override;
    
    
    virtual void flux(
      const double * __restrict__                  Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__ F // F[5]
    ) override;
    
     
    /**
     * Evaluate refinement criterion over cell
     *
     * @param Q Vector of unknowns
     * @param x Centre of underlying cell
     * @param h Size of underlying cell
     * @param t Time
     */
    ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__                  Q,    // Q[5+0]
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<Dimensions,double>&  h,
      double                                       t
    ) override;


    /**
     * According to the docu, I always call the superclass routine. After that,
     * I check whether this has been the last sweep of the current time step.
     * If so, we let the mass accummulation know.
     */
    void finishTimeStep() override;

    bool cellCanUseStatelessPDETerms(
      const tarch::la::Vector<Dimensions,double>&  patchCentre,
      const tarch::la::Vector<Dimensions,double>&  patchH,
      double                                       t,
      double                                       dt
    ) const override;
    
    
    /**
     * Manually inlined version of the source term. As this variant is only called
     * outside of the area of relevance, we know that the mass acting on the volume
     * is the total mass.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void sourceTerm(
       const double * __restrict__                  Q,
       const tarch::la::Vector<Dimensions,double>&  x,
       double                                       t,
       double                                       dt,
       double * __restrict__                        S,
       Offloadable
    ) {
      for (int i=0; i<NumberOfUnknowns; i++) {
        S[i] = 0.0;
      }

      applications::exahype2::euler::sphericalaccretion::addGravitationalSource_AlphaCDM(
        S,
        x,
        Q,
        TotalMassInPreviousTimeStep,
        aInitial,
        t
      );
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
    
    /**
     * Manually inlined. Otherwise the same as the virtual function without
     * the logging.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void flux(
      const double * __restrict__ Q,               // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  x,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__                        F, // F[5]
      Offloadable
    ) {
      ::applications::exahype2::euler::flux(
        Q,
        x,
        0.0, // no volume, as point-wise
        t,
        dt,
        normal,
        NumberOfUnknowns,
        NumberOfAuxiliaryVariables,
        F,
        Gamma
      );
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
};


