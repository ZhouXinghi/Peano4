//
// ExaHyPE2 solver file
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. If you change fundamental properties, you will have to 
// generate this file. Backup your manual changes before you do so.
//
#pragma once

#include "../../../../applications/exahype2/euler/EulerKernels.h"
#include "AbstractSelfSimilarInfallFV.h"
#include "tarch/logging/Log.h"

#include "spherical-accretion/MassAccumulator.h"
#include "spherical-accretion/GravityModel.h"



namespace benchmarks {
  namespace exahype2 {
    namespace euler {
      namespace sphericalaccretionupscaling {
        class SelfSimilarInfallFV;
      }
    }
  }
}


class benchmarks::exahype2::euler::sphericalaccretionupscaling::SelfSimilarInfallFV: public benchmarks::exahype2::euler::sphericalaccretionupscaling::AbstractSelfSimilarInfallFV {
  private:
    static tarch::logging::Log   _log;

    /**
     * Use class from application folders.
     */
    ::applications::exahype2::euler::sphericalaccretion::MassAccumulator  _accumulator;

    /**
     * After each time step, we backup the total mass in this static variable.
     * It has to be static, as we want to use it in stateless terms later on.
     */
    static double TotalMassInPreviousTimeStep;
  public:
    static constexpr double BaseDensity         = 0.1;
    static constexpr double Gamma               = 5.0/3.0;
    static constexpr double pInitial            = 1e-6;
    static constexpr double aInitial            = 0.001;
    static constexpr double AdditionalMass      = 0.15;
    static constexpr double InitialTopHatRadius = 0.05;

    SelfSimilarInfallFV();

    /**
     * Add density of one voxel to global bookkeeping
     */
    void addDensity(
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       density
    );


    /**
     * We start with a top hat overdensity. Please note that the initial overdensity
     * does not enter the initial fluxes: The Euler equation are totally agnostic in
     * principle of the density. However, the overdensity will enter the mass
     * accumulation in the first time step.
     *
     * It is important that we inject some initial energy into the system to close the
     * PDE. This energy can be the same everywhere to get the setup going, but we may
     * not set it to zero. If we do this, the system doesn't evolve at al.
     */
    void initialCondition(
      double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      bool                                         gridIsConstructed
    ) override;
    

    /**
     * Apply Neumann boundary conditions
     *
     * I'm super lazy here and rely on the pre-manufactured routine from the
     * EulerKernels.h which are shipped with the actual Euler application.
     */
    virtual void boundaryConditions(
      const double * __restrict__                  Qinside,
      double * __restrict__                        Qoutside,
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    )  override;
    

    /**
     * Fake source term
     *
     * The term is a fake, i.e. does not fit to the original paper force that you find
     * in the application folder. However, it shared some commonalities:
     *
     * - The force does not kick in immediately but fades in (a parameter).
     * - The force depends on the amount of mass (overdensity) from the voxel centre
     *   to the origin.
     * - The source forces always drag the solution towards the centre. That does not
     *   mean that we have fluid flow into that direction, as the pressure might
     *   actually be stronger and push the fluid away.
     * - The force scales with the density.
     */
    void sourceTerm(
      const double * __restrict__ Q,
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      double * __restrict__ S
    ) override;
    

    /**
     * Determine max eigenvalue over Jacobian in a given point with solution values
     * (states) Q. As we use the plain Euler equations and "solely" modify the
     * right-hand side compared to the baseline version, we can work with the
     * eigenvalue realisation as it is provided by the applications folds.
     *
     * @return Max eigenvalue. Result has to be positive, so we are actually speaking
     *   about the maximum absolute eigenvalue.
     */
    virtual double maxEigenvalue(
      const double * __restrict__                  Q,
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal
    ) override;
    

    /**
     * Same story again: This is the standard Euler flux which is independent of
     * any modification of the right-hand side.
     */
    virtual void flux(
      const double * __restrict__ Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__ F // F[5]
    ) override;
    

    ::exahype2::RefinementCommand refinementCriterion(
      const double * __restrict__ Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  volumeCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t
    ) override;


    /**
     * According to the docu, I always call the superclass routine. After that,
     * I check whether this has been the last sweep of the current time step.
     * If so, we let the mass accummulation know.
     */
    void finishTimeStep() override;


    /**
     * Manually inlined version of the source term. As this variant is only called
     * outside of the area of relevance, we know that the mass acting on the volume
     * is the total mass.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void sourceTerm(
       const double * __restrict__                  Q,
       const tarch::la::Vector<Dimensions,double>&  volumeCentre,
       const tarch::la::Vector<Dimensions,double>&  volumeH,
       double                                       t,
       double                                       dt,
       double * __restrict__                        S,
       Offloadable
    ) {
      for (int i=0; i<NumberOfUnknowns; i++) {
        S[i] = 0.0;
      }

      applications::exahype2::euler::sphericalaccretion::addGravitationalSource_AlphaCDM(
        S,
        volumeCentre,
        Q,
        TotalMassInPreviousTimeStep,
        aInitial,
        t
      );
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif

    
    /**
     * Manually inlined. Otherwise the same as the virtual function without
     * the logging.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod double maxEigenvalue(
      const double * __restrict__ Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      Offloadable
    ) {
      return ::applications::exahype2::euler::maxEigenvalue(
          Q,
          faceCentre,
          volumeH,
          t,
          dt,
          normal,
          NumberOfUnknowns,
          NumberOfAuxiliaryVariables,
          Gamma
        );
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif
    


    
    /**
     * Manually inlined. Otherwise the same as the virtual function without
     * the logging.
     */
    #if defined(GPUOffloadingOMP)
    #pragma omp declare target
    #endif
    static GPUCallableMethod void flux(
      const double * __restrict__ Q, // Q[5+0],
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      double                                       dt,
      int                                          normal,
      double * __restrict__                        F, // F[5]
      Offloadable
    ) {
      ::applications::exahype2::euler::flux(
        Q,
        faceCentre,
        volumeH,
        t,
        dt,
        normal,
        NumberOfUnknowns,
        NumberOfAuxiliaryVariables,
        F,
        Gamma
      );
    }
    #if defined(GPUOffloadingOMP)
    #pragma omp end declare target
    #endif


    /**
     * Outside of the critical area, we can use the stateless PDE terms.
     */
    bool patchCanUseStatelessPDETerms(
      const tarch::la::Vector<Dimensions,double>&  patchCentre,
      const tarch::la::Vector<Dimensions,double>&  patchH,
      double                                       t,
      double                                       dt
    ) const override;

//    Die Information was ausserhalb liegt, wird noch net im guard genutzt
};


