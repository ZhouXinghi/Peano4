# This file is part of the DaStGen2 project. For conditions of distribution and
# use, please see the copyright notice at www.peano-framework.org
import dastgen2
import os


class DataModel(object):
    """! Represents on DaStGen2 object, i.e. one data model.

    full_qualified_name  Full qualified name. Please pass in in C++ convention i.e. with
                         :: separating the namespaces.

    """

    def __init__(
        self,
        full_qualified_name,
        has_nondefault_constructor=True,
        embed_attributes_into_data_store=False,
    ):
        self._full_qualified_name = full_qualified_name
        self._attributes = []
        self._aspects = []
        self.has_nondefault_constructor = has_nondefault_constructor
        self._embed_attributes_into_data_store = embed_attributes_into_data_store

    def set_full_qualified_name(self, full_qualified_name):
        self._full_qualified_name = full_qualified_name

    def add_attribute(self, attribute):
        attribute.use_data_store = self._embed_attributes_into_data_store
        self._attributes.append(attribute)

    def add_or_replace_attribute(self, attribute):
        """
        Check first whether attribute already exists. If it does, replace it.
        """

        attribute.use_data_store = self._embed_attributes_into_data_store

        for i, att in enumerate(self._attributes):
            if att._name == attribute._name:
                self._attributes[i] = attribute
                return

        # if we make it here, it's a new attribute.
        self._attributes.append(attribute)
        return

    def add_aspect(self, aspect):
        aspect.set_model(self)
        self._aspects.append(aspect)

    _Header_Template_Without_Data_Store = """
//
// Generated by DaStGen2 (C) 2020 Tobias Weinzierl
//
// For DaStGen's copyright, visit www.peano-framework.org. These generated files
// however are not subject of copyright, i.e. feel free to add your copyright in
// here
//
#pragma once

#include <string>

{ATTRIBUTE_INCLUDES}
{ASPECT_INCLUDES}

{OPEN_NAMESPACES}
  struct {UNQUALIFIED_CLASS_NAME};
{CLOSE_NAMESPACES}


struct {FULL_QUALIFIED_CLASS_NAME} {{
  public:
{PUBLIC_FIELDS}

    {UNQUALIFIED_CLASS_NAME}() {{}}
    {UNQUALIFIED_CLASS_NAME}{CONSTRUCTOR_ARGUMENTS};


{METHOD_DECLARATIONS}

{ASPECT_METHOD_DECLARATIONS}
    std::string toString() const;

  private:
{ATTRIBUTE_DECLARATIONS}

{ASPECT_ATTRIBUTES}

}};

  """

    _Header_Template_With_Data_Store = """
//
// Generated by DaStGen2 (C) 2020 Tobias Weinzierl
//
// For DaStGen's copyright, visit www.peano-framework.org. These generated files
// however are not subject of copyright, i.e. feel free to add your copyright in
// here
//
#pragma once

#include <string>

{ASPECT_INCLUDES}

{OPEN_NAMESPACES}
  struct {UNQUALIFIED_CLASS_NAME};
{CLOSE_NAMESPACES}


struct {FULL_QUALIFIED_CLASS_NAME} {{
  public:
{PUBLIC_FIELDS}

    {UNQUALIFIED_CLASS_NAME}() {{}}
    {UNQUALIFIED_CLASS_NAME}{CONSTRUCTOR_ARGUMENTS};

{METHOD_DECLARATIONS}

{ASPECT_METHOD_DECLARATIONS}
    std::string toString() const;

  private:
    struct DataStore {{
{ATTRIBUTE_DECLARATIONS}
    }};

{ASPECT_ATTRIBUTES}

    DataStore _dataStore;
}};

  """

    def _get_constructor_arguments(self):
        """
        Generates the list of constructor arguments needed to fully
        instantiate an object of the class the datamodel generates.
        """
        result = "("
        is_first = True
        for attribute in self._attributes:
            if (
                attribute._is_static
                or attribute._is_const_static
                or attribute._is_constexpr
                or attribute._is_const
            ):
                continue
            for entry in attribute.get_constructor_arguments():
                if not is_first:
                    result += ", "
                is_first = False
                result += entry[1] + "  _" + entry[0]
        result += ")"
        return result

    def __use_default_copy_constructor(self):
        use_default_constructor = True
        for attribute in self._attributes:
            use_default_constructor = (
                use_default_constructor and attribute.use_default_copy_constructor()
            )
        return use_default_constructor

    def write_header_file(self, full_qualified_filename):
        """!
        writes the header file for your data model.
        """
        d = {}
        d["ATTRIBUTE_INCLUDES"] = ""
        for attribute in self._attributes:
            d["ATTRIBUTE_INCLUDES"] += attribute.get_includes()

        d["UNQUALIFIED_CLASS_NAME"] = dastgen2.get_unqualified_class_name(
            self._full_qualified_name
        )
        d["FULL_QUALIFIED_CLASS_NAME"] = self._full_qualified_name
        d["OPEN_NAMESPACES"] = ""
        d["CLOSE_NAMESPACES"] = ""
        d["SETTER_GETTER_DECLARATIONS"] = ""
        for i in dastgen2.get_namespaces(self._full_qualified_name):
            d["OPEN_NAMESPACES"] += "namespace " + i + "{\n"
            d["CLOSE_NAMESPACES"] += "}\n"

        d["PUBLIC_FIELDS"] = ""
        for attribute in self._attributes:
            d["PUBLIC_FIELDS"] += attribute.get_public_fields()

        d["ATTRIBUTE_DECLARATIONS"] = ""
        for attribute in self._attributes:
            d["ATTRIBUTE_DECLARATIONS"] += attribute.get_attribute_declaration_string()

        d["METHOD_DECLARATIONS"] = ""
        for attribute in self._attributes:
            if attribute.ifdefs != []:
                d["METHOD_DECLARATIONS"] += dastgen2.construct_ifdef_string(
                    attribute.ifdefs
                )
            for method in attribute.get_methods(
                self._full_qualified_name, for_declaration=True
            ):
                d["METHOD_DECLARATIONS"] += "    "
                if attribute.expose_in_header_file:
                    d["METHOD_DECLARATIONS"] += " inline "
                d["METHOD_DECLARATIONS"] += method[1] + "   " + method[0] + ";\n"
            if attribute.ifdefs != []:
                d["METHOD_DECLARATIONS"] += "#endif \n"

        d["ASPECT_ATTRIBUTES"] = ""
        d["ASPECT_METHOD_DECLARATIONS"] = ""
        # Inlcudes to peano4 should not exist in tarch
        # As tarch do not uses the definition Dimensions, but peano4 needs it (2 or 3 for example)
        d["ASPECT_INCLUDES"] = ""
        for i in self._aspects:
            
            d["ASPECT_ATTRIBUTES"] += i.get_attributes() + "\n"
            d["ASPECT_METHOD_DECLARATIONS"] += (
                i.get_method_declarations(self._full_qualified_name) + "\n"
            )
            include = i.get_include()
            # Do not include peano4 aspects in tarch files, due to the dimensions definitions
            filtered_includes = ""
            for line in include.split("\n"):
                if not("tarch" in d["FULL_QUALIFIED_CLASS_NAME"] and line.startswith('#include "peano4')):
                    filtered_includes += line + "\n"

            d["ASPECT_INCLUDES"] += filtered_includes+ "\n"
        d["CONSTRUCTOR_ARGUMENTS"] = self._get_constructor_arguments()
        if self.__use_default_copy_constructor():
            d["METHOD_DECLARATIONS"] += (
                "    "
                + dastgen2.get_unqualified_class_name(self._full_qualified_name)
                + "(const "
                + dastgen2.get_unqualified_class_name(self._full_qualified_name)
                + "& copy) = default;"
            )
        else:
            d["METHOD_DECLARATIONS"] += (
                "    "
                + dastgen2.get_unqualified_class_name(self._full_qualified_name)
                + "(const "
                + dastgen2.get_unqualified_class_name(self._full_qualified_name)
                + "& copy);"
            )

        if full_qualified_filename.find("/") != -1:
            path = full_qualified_filename[0 : full_qualified_filename.rfind("/")]
            if not os.path.exists(path):
                os.mkdir(path)
        with open(full_qualified_filename, "w") as output:
            if self._embed_attributes_into_data_store:
                output.write(self._Header_Template_With_Data_Store.format(**d))
            else:
                output.write(self._Header_Template_Without_Data_Store.format(**d))

            self.__generate_accessors(output, False)
            output.write("\n\n\n")

    def __generate_constructor_definition(self, output):
        """

        In this generation business, I faced multiple issues with initialisation
        lists: where are comma if some fields are not defined, which fields can
        I copy directly, and which ones do I have to copy manually, and so forth.


        """
        output.write(
            self._full_qualified_name
            + "::"
            + dastgen2.get_unqualified_class_name(self._full_qualified_name)
            + self._get_constructor_arguments()
        )

        output.write("{\n")
        for attribute in self._attributes:
            if (
                attribute._is_static
                or attribute._is_const_static
                or attribute._is_constexpr
                or attribute._is_const
            ):
                # no need to copy static class fields.
                continue

            if attribute.ifdefs != []:
                output.write(dastgen2.construct_ifdef_string(attribute.ifdefs))
            output.write(
                "set"
                + attribute._name[0].title()
                + attribute._name[1:].split("[")[0]
                + "( __"
                + attribute._name.split("[")[0]
                + ");\n"
            )
            if attribute.ifdefs != []:
                output.write("#endif \n")
        output.write("}\n")

    def __generate_toString_definition(self, output):
        output.write(
            "std::string " + self._full_qualified_name + "::toString() const {\n"
        )
        output.write("  std::ostringstream out;\n")
        output.write('  out << "(";\n')
        for attribute in self._attributes:
            if attribute.ifdefs != []:
                output.write(dastgen2.construct_ifdef_string(attribute.ifdefs))
            if self._attributes.index(attribute) != 0:
                output.write("""  out << ","; \n""")
            output.write(
                '  out << "'
                + attribute._name
                + '=" << '
                + attribute.get_to_string()
                + ";\n"
            )
            if attribute.ifdefs != []:
                output.write("#endif \n")

        output.write('  out << ")";\n')
        output.write("  return out.str();\n")
        output.write("}\n\n\n")

    def __generate_explicit_copy_constructor(self, output):
        output.write(
            self._full_qualified_name
            + "::"
            + dastgen2.get_unqualified_class_name(self._full_qualified_name)
            + "( const "
            + dastgen2.get_unqualified_class_name(self._full_qualified_name)
            + "& copy ) {\n"
        )
        for attribute in self._attributes:
            if (
                attribute._is_static
                or attribute._is_const_static
                or attribute._is_constexpr
                or attribute._is_const
            ):
                # no need to copy static class fields.
                continue
            if attribute.ifdefs != []:
                output.write(dastgen2.construct_ifdef_string(attribute.ifdefs))
            uppercase_name = attribute.name[0].upper() + attribute.name[1:]
            output.write(
                "  set" + uppercase_name + "( copy.get" + uppercase_name + "() );\n"
            )
            if attribute.ifdefs != []:
                output.write("#endif \n")
        output.write("}\n\n\n")

    def __generate_accessors(self, output, is_cpp_file):
        """!

        Generate getter/setter functions.

        Generate all the setters and getters and use get_methods() to
        construct them for the individual attributes.

        output: File object
            File object that will be written to.

        is_cpp_file: Boolean.
            True if the output is intended to be the .cpp file. False if it's
            the header file.

        """
        for attribute in self._attributes:
            if attribute.expose_in_header_file != is_cpp_file:
                if attribute.ifdefs != []:
                    output.write(dastgen2.construct_ifdef_string(attribute.ifdefs))
                for method in attribute.get_methods(
                    self._full_qualified_name, for_declaration=False
                ):
                    output.write(
                        method[1]
                        + "   "
                        + self._full_qualified_name
                        + "::"
                        + method[0]
                        + " {\n"
                    )
                    output.write(attribute.get_method_body(method[0]))
                    output.write("}\n\n\n")
                if attribute.ifdefs != []:
                    output.write("#endif \n\n\n")

    def write_implementation_file(self, full_qualified_filename):
        """!
        writes the implementation (.cpp) file for your data model.
        """
        with open(full_qualified_filename, "w") as output:
            output.write(
                '#include "'
                + dastgen2.get_unqualified_class_name(self._full_qualified_name)
                + '.h"\n\n\n'
            )

            output.write(
                """
#include <sstream>
#include <algorithm>



"""
            )

            if self.has_nondefault_constructor:
                self.__generate_constructor_definition(output)
                output.write("\n\n\n")

            if not self.__use_default_copy_constructor():
                self.__generate_explicit_copy_constructor(output)
                output.write("\n\n\n")

            self.__generate_toString_definition(output)
            output.write("\n\n\n")

            self.__generate_accessors(output, True)
            output.write("\n\n\n")

            for aspect in self._aspects:
                output.write(aspect.get_implementation(self._full_qualified_name))

    def expose_all_attributes_in_header_file(self):
        for i in self._attributes:
            i.expose_in_header_file = True
