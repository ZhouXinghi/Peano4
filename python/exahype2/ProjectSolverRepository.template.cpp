// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#include "SolverRepository.h"
#include "peano4/grid/grid.h"
#include "peano4/parallel/SpacetreeSet.h"

#include "exahype2/LoadBalancingConfiguration.h"
#include "exahype2/RefinementControlService.h"
#include "exahype2/UserInterface.h"

#include "tarch/multicore/Core.h"
#include "tarch/accelerator/Device.h"

#include "Constants.h"


{% for item in TRACERS -%}
#include "vertexdata/{{ item }}Set.h"
#include "globaldata/{{ item }}.h"
{# Comment to ensure that jinja2 adds a new line#}
{%- endfor %}


{% for INCLUDE in ADDITIONAL_INCLUDES %}
#include "{{INCLUDE}}"
{% endfor %}


#include <algorithm>

{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}

int statisticsExchangeTag = tarch::mpi::Rank::reserveFreeTag("SolverRepository - statistics exchange tag");

tarch::logging::Log _log( "{{NAMESPACE | join("::")}}::SolverRepository" );

::exahype2::PlotFilter         plotFilter;
peano4::grid::GridStatistics   gridStatisticsAfterGridConstruction;


{% if LOAD_BALANCER!="" -%}
{{LOAD_BALANCER}}              loadBalancer({{LOAD_BALANCER_ARGUMENTS}});
{% else -%}
toolbox::loadbalancing::strategies::NoLoadBalancing  loadBalancer;
{% endif -%}



{% for item in SOLVERS -%}
{{ item[0] }} {{ item[1] }};
{# Comment to ensure that jinja2 adds a new line#}
{%- endfor %}


bool mayPlot() {
  bool result = true;
  {% for item in SOLVERS -%}
  result &= {{ item[1] }}.mayPlot();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


std::string getSolverStateDescriptions() {
  std::ostringstream result;
  {% for item in SOLVERS -%}
  if (not result.str().empty()) result << ", ";
  result << "{{ item[1] }}:" << {{ item[1] }}.toString( {{ item[1] }}.getSolverState() );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result.str();
}


bool isFirstGridSweepOfTimeStep() {
  bool result = true;
  {% for item in SOLVERS -%}
  result &= {{ item[1] }}.isFirstGridSweepOfTimeStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


bool isLastGridSweepOfTimeStep() {
  bool result = true;
  {% for item in SOLVERS -%}
  result &= {{ item[1] }}.isLastGridSweepOfTimeStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMinTimeStamp(bool ofCurrentlyRunningGridSweep) {
  double result = std::numeric_limits<double>::max();
  {% for item in SOLVERS -%}
  result = std::min( result, {{ item[1] }}.getMinTimeStamp(ofCurrentlyRunningGridSweep) );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMaxTimeStamp(bool ofCurrentlyRunningGridSweep) {
  double result = 0.0;
  {% for item in SOLVERS -%}
  result = std::max( result, {{ item[1] }}.getMaxTimeStamp(ofCurrentlyRunningGridSweep) );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMinMeshSize() {
  double result = std::numeric_limits<double>::max();
  {% for item in SOLVERS -%}
  result = std::min( result, {{ item[1] }}.getMinMeshSize() );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMaxMeshSize() {
  double result = 0;
  {% for item in SOLVERS -%}
  result = std::max( result, {{ item[1] }}.getMaxMeshSize() );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMaxAdmissibleMeshSize() {
  double result = std::numeric_limits<double>::max();
  {% for item in SOLVERS -%}
  result = std::min( result, {{ item[1] }}.MaxAdmissibleCellH );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMinAdmissibleMeshSize() {
  double result = 0.0;
  {% for item in SOLVERS -%}
  result = std::max( result, {{ item[1] }}.MinAdmissibleCellH );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMinTimeStepSize() {
  double result = std::numeric_limits<double>::max();
  {% for item in SOLVERS -%}
  result = std::min( result, {{ item[1] }}.getMinTimeStepSize() );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


double getMaxTimeStepSize() {
  double result = 0.0;
  {% for item in SOLVERS -%}
  result = std::max( result, {{ item[1] }}.getMaxTimeStepSize() );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  return result;
}


void suspendSolversForOneGridSweep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.suspendSolversForOneGridSweep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
}


void startGridConstructionStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.startGridConstructionStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  logTraceIn( "GridConstructionStep()" );
}


void startGridInitialisationStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.startGridInitialisationStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  logTraceIn( "GridInitialisationStep()" );
}


void startTimeStep(
  double minTimeStamp,
  double maxTimeStamp,
  double minTimeStepSize,
  double maxTimeStepSize
) {
  {% for item in SOLVERS -%}
  {{ item[1] }}.startTimeStep(minTimeStamp,maxTimeStamp,minTimeStepSize,maxTimeStepSize);
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  logTraceIn( "TimeStep()" );
}


void startPlottingStep(
  double minTimeStamp,
  double maxTimeStamp,
  double minTimeStepSize,
  double maxTimeStepSize
) {
  {% for item in SOLVERS -%}
  {{ item[1] }}.startPlottingStep(minTimeStamp,maxTimeStamp,minTimeStepSize,maxTimeStepSize);
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  logTraceIn( "PlottingStep()" );
}


void finishTimeStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.finishTimeStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  {% for item in TRACERS -%}
  vertexdata::{{ item }}Set::finishedTraversal(
    DomainOffset,
    DomainSize,
    PeriodicBC
  );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  ::exahype2::RefinementControlService::getInstance().finishStep();
  loadBalancer.finishStep();

  #ifdef UseSmartMPI
  smartmpi::tick();
  #endif
  logTraceOut( "TimeStep()" );
}


void finishGridConstructionStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.finishGridConstructionStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  {% for item in TRACERS -%}
  vertexdata::{{ item }}Set::finishedTraversal(
      DomainOffset,
      DomainSize,
      PeriodicBC
    );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  ::exahype2::RefinementControlService::getInstance().finishStep();
  loadBalancer.finishStep();

  gridStatisticsAfterGridConstruction = peano4::parallel::SpacetreeSet::getInstance().getGridStatistics();
  #ifdef Parallel
  if ( tarch::mpi::Rank::getInstance().isGlobalMaster() ) {
    for (int rank=0; rank<tarch::mpi::Rank::getInstance().getNumberOfRanks(); rank++ ) {
      if (rank!=tarch::mpi::Rank::getGlobalMasterRank()) {
        peano4::grid::GridStatistics rankLocalStats;
        logDebug( "GridConstructionStep()", "receive grid statistics from rank " << rank << " via tag " << statisticsExchangeTag );
        peano4::grid::GridStatistics::receive(
          rankLocalStats,
          rank,
          statisticsExchangeTag,
          [&]() {
            tarch::mpi::Rank::getInstance().setDeadlockWarningTimeStamp();
            tarch::mpi::Rank::getInstance().setDeadlockTimeOutTimeStamp();
          },
          [&]() {
            tarch::mpi::Rank::getInstance().writeTimeOutWarning( "{{NAMESPACE | join("::")}}", "finishGridConstructionStep()", rank, statisticsExchangeTag );
            tarch::mpi::Rank::getInstance().triggerDeadlockTimeOut( "{{NAMESPACE | join("::")}}", "finishGridConstructionStep()", rank, statisticsExchangeTag );
            tarch::services::ServiceRepository::getInstance().receiveDanglingMessages();
          },
          tarch::mpi::Rank::getInstance().getCommunicator()
        );
        gridStatisticsAfterGridConstruction = gridStatisticsAfterGridConstruction + rankLocalStats;
      }
    }
  }
  else {
    logDebug( "GridConstructionStep()", "send out local statistics " << gridStatisticsAfterGridConstruction.toString() << " to global master via tag " << statisticsExchangeTag );
    peano4::grid::GridStatistics::send(
      gridStatisticsAfterGridConstruction,
      tarch::mpi::Rank::getInstance().getGlobalMasterRank(),
      statisticsExchangeTag,
      [&]() {
        tarch::mpi::Rank::getInstance().setDeadlockWarningTimeStamp();
        tarch::mpi::Rank::getInstance().setDeadlockTimeOutTimeStamp();
      },
      [&]() {
        tarch::mpi::Rank::getInstance().writeTimeOutWarning( "", "receive()", tarch::mpi::Rank::getInstance().getGlobalMasterRank(), statisticsExchangeTag );
        tarch::mpi::Rank::getInstance().triggerDeadlockTimeOut( "", "receive()", tarch::mpi::Rank::getInstance().getGlobalMasterRank(), statisticsExchangeTag );
        tarch::services::ServiceRepository::getInstance().receiveDanglingMessages();
      },
      tarch::mpi::Rank::getInstance().getCommunicator()
    );
  }
  #endif
  logTraceOut( "GridConstructionStep()" );
}


void finishGridInitialisationStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.finishGridInitialisationStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  {% for item in TRACERS -%}
  vertexdata::{{ item }}Set::finishedTraversal(
      DomainOffset,
      DomainSize,
      PeriodicBC
    );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  loadBalancer.finishStep();
  logTraceOut( "GridInitialisationStep()" );
}


void finishPlottingStep() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.finishPlottingStep();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  {% for item in TRACERS -%}
  vertexdata::{{ item }}Set::finishedTraversal(
      DomainOffset,
      DomainSize,
      PeriodicBC
    );
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

  plotFilter.finishPlottingStep();
  logTraceOut( "PlottingStep()" );
}


void startSimulation() {
  {% for item in PLOT_FILTER -%}
  plotFilter.addFilter(
    {{item}}
  );
  {% endfor %}
  {% for item in SOLVERS -%}
  {{ item[1] }}.startSimulation();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}

}


void finishSimulation() {
  {% for item in SOLVERS -%}
  {{ item[1] }}.finishSimulation();
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}
  loadBalancer.finishStep();
  ::exahype2::RefinementControlService::getInstance().finishStep();
}


void initLogFilters() {
  {% if LOG_FILTER_FILE!="" %}
  if ( not tarch::logging::LogFilterFileReader::parsePlainTextFile( "{{LOG_FILTER_FILE}}" ) ) {
    // manual selection, as log filters are not there yet
    if (tarch::mpi::Rank::getInstance().isGlobalMaster()) {
      logWarning( "main()", "filter file {{LOG_FILTER_FILE}} not found or file has been corrupted. Use default logging configuration" );
    }
    ::exahype2::setDefaultLogStatements();
  }
  {% else %}
  ::exahype2::setDefaultLogStatements();
  {% endif %}
}

void initSharedMemoryAndGPUEnvironment() {

  {% if TIMEOUT>=0 %}
  tarch::mpi::Rank::getInstance().setDeadlockTimeOut( {{TIMEOUT}} );
  {% endif %}
  tarch::multicore::Core::getInstance().configure( {{NUMBER_OF_THREADS}} );
  tarch::accelerator::Device::getInstance().configure( { {{GPUS|join(",")}} } );
  tarch::multicore::setOrchestration( {{MULTICORE_ORCHESTRATION}} );

}


{% for item in NAMESPACE -%}
  }

{%- endfor %}

