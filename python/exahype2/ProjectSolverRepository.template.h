// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once

#include "toolbox/loadbalancing/strategies/NoLoadBalancing.h"

{% if LOAD_BALANCER!="" -%}
#include "{{LOAD_BALANCER | replace('::', '/') }}.h"
{% endif -%}

#include "exahype2/RefinementControl.h"
#include "exahype2/PlotFilter.h"
#include "peano4/grid/GridStatistics.h"

{% for item in SOLVERS -%}
#include "{{ item[0] }}.h"
{# Comment to ensure that jinja2 adds a new line#}
{% endfor %}


{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}

  {% for item in SOLVERS -%}
  extern {{ item[0] }}  {{ item[1] }};
  {# Comment to ensure that jinja2 adds a new line#}
  {%- endfor %}


  extern ::exahype2::RefinementControl  refinementControl;
  extern ::exahype2::PlotFilter         plotFilter;

  {% if LOAD_BALANCER!="" -%}
  extern {{LOAD_BALANCER}}              loadBalancer;
  {% else -%}
  extern toolbox::loadbalancing::strategies::NoLoadBalancing  loadBalancer;
  {% endif -%}

  extern peano4::grid::GridStatistics   gridStatisticsAfterGridConstruction;

  /**
   * Return the global min time stamp over all solvers.
   *
   * There are two different flavours of a minimal time stamp: On the one hand,
   * there's a global minimum time stamp over all solvers. This might not
   * be the min time stamp after the last update. If you have local time
   * stepping, then some cells might just have done a tiny time step,
   * whereas the big cells still span a large time span. Hence, no the other
   * hand, there's also a (time-)local time stamp.
   */
  double getMinTimeStamp(bool ofCurrentlyRunningGridSweep = false);

  /**
   * Return max time stamp of all solvers.
   *
   * This routine returns the minimum over the maximum time stamp of all
   * solvers. It is important that we use the minimum here: We usually want
   * to know how far in the future all the solvers are, but we still want to
   * know what a valid time stamp is. So we have to take the minimum here.
   */
  double getMaxTimeStamp(bool ofCurrentlyRunningGridSweep = false);
  double getMinTimeStepSize();
  double getMaxTimeStepSize();
  double getMinMeshSize();
  double getMaxMeshSize();

  /**
   * This routine returns the minimum of the max admissible mesh sizes.
   */
  double getMaxAdmissibleMeshSize();

  /**
   * Return max of min admissible mesh sizes.
   */
  double getMinAdmissibleMeshSize();

  void startGridConstructionStep();
  void startGridInitialisationStep();

  /**
   * Start a new time step
   *
   * The solvers analyse their current solver state and toggle it. After
   * this routine is called, the solvers' states remain invariant until
   * the next startTimeStep() call or a suspension. Notably,
   * finishTimeStep() does not alter the solvers' states.
   */
  void startTimeStep(
    double globalMinTimeStamp,
    double globalMaxTimeStamp,
    double globalMinTimeStepSize,
    double globalMaxTimeStepSize
  );

  void startPlottingStep(
    double globalMinTimeStamp,
    double globalMaxTimeStamp,
    double globalMinTimeStepSize,
    double globalMaxTimeStepSize
  );

  void finishGridConstructionStep();
  void finishGridInitialisationStep();

  /**
   * @see startTimeStep()
   */
  void finishTimeStep();
  void finishPlottingStep();

  void startSimulation();
  void finishSimulation();

  bool mayPlot();

  /**
   * Is this the first sweep of a time step
   *
   * This query should be used with care within a user function and only once
   * you have studied isLastGridSweepOfTimeStep(). startTimeStep() switches
   * into this state. That is, when you call startTimeStep() and it turns out
   * to be the first sweep, the predicate will be true after startTimeStep()
   * has been called, and it will be true once the first mesh sweep has
   * terminated and the control comes back to the main routine. It is nice to
   * query stuff, but you should not "disturb" the solvers' mesh sweep
   * sequence. If you have a Runge-Kutta solver for example, the fact that this
   * predicate holds means that you've just finished the very first mesh
   * run-through of a time step, but the time step overall is not finished
   * yet.
   */
  bool isFirstGridSweepOfTimeStep();

  /**
   * Is this the last sweep of a time step
   *
   * Some solvers require multiple mesh sweeps to realise their behaviour.
   * Runge-Kutta solvers and enclave solvers are the most prominent examples.
   * Once you call startTimeStep() for the last time, the internal states will
   * toggle and this predicate will hold. After the time step has terminated
   * and finishTimeStep() has been called, this predicate holds. That is, you
   * can query it in the main and find out that a solver has just finished its
   * time step.
   */
  bool isLastGridSweepOfTimeStep();

  void suspendSolversForOneGridSweep();

  void initLogFilters();

  void initSharedMemoryAndGPUEnvironment();

  /**
   * Concatenates all the toString() results from the solvers.
   *
   * Gives you one long string of the states of the solvers. If you study the
   * states within the main of the simulation (the application driver so to
   * say), these states denote the states that the solvers will have in the
   * upcoming mesh sweep.
   */
  std::string getSolverStateDescriptions();

{% for item in NAMESPACE -%}
  }
{%- endfor %}


