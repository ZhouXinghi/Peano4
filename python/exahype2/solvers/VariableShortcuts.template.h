// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once

{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}
  struct VariableMetrics;
  class VariableShortcuts;
{% for item in NAMESPACE -%}
  }
{%- endfor %}

struct {{NAMESPACE | join("::")}}::VariableMetrics {
  static constexpr int NumberOfDistinctVariables  = {{VARIABLE_NAMES|length}};
  static constexpr int NumberOfUnknowns           = {{NUMBER_OF_UNKNOWNS}};
  static constexpr int NumberOfAuxiliaryVariables = {{NUMBER_OF_AUXILIARY_VARIABLES}};
  static constexpr int Size                       = {{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}};
};

/**
 * Positions of fields in the vector of unknowns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation.
 */
class {{NAMESPACE | join("::")}}::VariableShortcuts : public {{NAMESPACE | join("::")}}::VariableMetrics {
public:
  // Positions of fields inside the unknown vector (solution vector) Q
  static constexpr int Q[NumberOfDistinctVariables + 1] = { {% for VARIABLE_NO in range(0, VARIABLE_NAMES|length-1) -%}
  {{VARIABLE_POSITIONS[VARIABLE_NO]}},
{%- endfor %} {{VARIABLE_POSITIONS[VARIABLE_NAMES|length-1]}} };

  {% for VARIABLE_NO in range(0, VARIABLE_NAMES|length) %}
    static constexpr int {{VARIABLE_NAMES[VARIABLE_NO]}} = {{VARIABLE_POSITIONS[VARIABLE_NO]}};
  {% endfor %}

  constexpr int operator [] (const int index) const noexcept { return Q[index]; }
  constexpr int operator () (const int index) const noexcept { return Q[index]; }
};
