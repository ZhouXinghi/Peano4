// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once

#include "Constants.h"

#include "exahype2/RefinementControl.h"
#include "exahype2/PrecisionControl.h"
#include "exahype2/aderdg/solvers/ADERDGSolver.h"

#include "tarch/la/Vector.h"
#include "tarch/multicore/BooleanSemaphore.h"
#include "tarch/NonCriticalAssertions.h"

#include "peano4/utils/Globals.h"

#include "exahype2/aderdg/kernels/Kernels.h"
{% if USE_KERNEL_GENERATOR %}
#include "generated/kernels/aderdg/{{LINEARITY}}/Quadrature.h"
#include "generated/kernels/aderdg/{{LINEARITY}}/DGMatrices.h"
{% endif %}

{% if USE_HALF_PRECISION==True %}
#include <stdfloat>
{% endif %}

{% if USE_VARIABLE_SHORTCUT is sameas True %}
#include "VariableShortcuts.h"
{% endif %}

{{SOLVER_INCLUDES}}

{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}

class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public ::exahype2::solvers::aderdg::ADERDGSolver {
  public:
    /**
     * This is a "fake" enum, i.e. we do not use it to distinguish different
     * variants. Instead, we use it as a fix that allows us to "overload"
     * operations:
     *
     * In C++ you cannot overload w.r.t. static. We however need functions which
     * exist twice in ExaHyPE: Once as standard (virtual) member functions and
     * once at static version which an be offloaded to a GPU as it does not
     * have a state. Both function variants, in theory, have the same signature
     * but if they had, a compiler could not distinguish them. So I use this
     * enum for the GPU version.
     *
     * If you create a solver without GPU support, this enum will not be used.
     * It is however always created. Once you write a GPU version and then compile
     * without GPU support, you will thus still be able to have all your GPU
     * function variants, and you don't have to work with ifdefs.
     */
    enum class Offloadable {
      Yes
    };

    enum class SolverState {
      GridConstruction,
      GridInitialisation,
      Prediction,
      PredictionOnHangingCells,
      Correction,
      Plotting,
      Suspended
    };

    static std::string toString(SolverState);

    static constexpr int    Order                      = {{ORDER}};
    static constexpr int    NumberOfUnknowns           = {{NUMBER_OF_UNKNOWNS}};
    static constexpr int    NumberOfAuxiliaryVariables = {{NUMBER_OF_AUXILIARY_VARIABLES}};
    static constexpr int    MaxPicardIterations        = {{ORDER}}+1;
    static constexpr bool   UseMaxPicardIterations     = true;
    static constexpr bool   UseLobattoBasis            = {{USE_GAUSS_LOBATTO}};
    static constexpr double CFL                        = {{CFL_SAFETY_FACTOR}};
    static constexpr double PNPM                       = {{CFL_ADER}};
    
    {% if USE_POINT_SOURCE!="<none>" %}
    static constexpr int NumberOfPointSources     = {{NUMBER_OF_POINT_SOURCES}};
    double pointSourceLocation[NumberOfPointSources][Dimensions];
    {% endif %}

    /**
     * Maximum mesh size that this solver wants/is allowed to support. Peano 4
     * has to ensure that none of its ExaHyPE 2 solvers has to work on a mesh
     * which is coarser than its MaxH value.
     */
    static constexpr double MaxAdmissibleCellH  = {{MAX_CELL_H}};

    /**
     * Minimum mesh size that this solver wants to support. Peano 4 tries
     * to ensure that none of its ExaHyPE 2 solvers has to work on a mesh
     * which is finer than its MinH value. However, if there are multiple
     * solvers, the interplay of these solvers might imply that some solvers
     * work with fine mesh resolutions even though they have specified a
     * coarser MinH.
     */
    static constexpr double MinAdmissibleCellH  = {{MIN_CELL_H}};
    
    
    /*
     * Maximal mesh size that can actually be reached, this is the greatest size
     * that can be reached by 3-subdivision of the domain size but is still lower
     * than MaxAdmissibleCellH
     * Minimal and maximal levels of the mesh, i.e upper and lower limits
     * for how many times the mesh can be divided in order to keep it in
     * between the maximal and minimal admissible cell sizes
     */
    double realCoarsestMeshSize;
    double coarsestMeshLevel;
    double maxAdaptiveMeshLevel;
    

    /**
     * Quadrature points, derivative operators, and various projectors for (1D) unit interval.
     */
    {{BASIS_DECLARATIONS | indent(4,True) }}

    {{CLASSNAME}}();
    ~{{CLASSNAME}}();

    /**
     * Alias for periodic boundary conditions.
     */
    static std::bitset<Dimensions> PeriodicBC;

    double getMinTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;
    double getMaxTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;
    double getMinTimeStepSize() const final;
    double getMaxTimeStepSize() const final;


    /**
     * Evaluate refinement criterion over cell
     *
     * @param Q Vector of unknowns
     * @param x Centre of underlying cell
     * @param h Size of underlying cell
     * @param t Time
     */
    virtual ::exahype2::RefinementCommand refinementCriterion(
      const {{SOLUTION_STORAGE_PRECISION}} * __restrict__                  Q,    // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const tarch::la::Vector<Dimensions,double>&  x,
      const tarch::la::Vector<Dimensions,double>&  h,
      double                                       t
    ) {% if REFINEMENT_CRITERION_IMPLEMENTATION=="<user-defined>" %}= 0{% else %} final {% endif %};


    /**
     *
     * @param x     Position of point that is to be initialised within computational domain.
     * @param h     Size of cell within which the point is placed.
     * @param index Index of point within cell. This one can be used to look up which shape
     *              function is tied to the point. You just have to scale it with h. By
     *              translating the shape function's centre to x, you can reconstruct where
     *              the shape function is placed within the computational domain.
     * @param gridIsConstructed Boolean holds if grid is completely constructed.
     *              initialCondition() is invoked both by the grid construction and the
     *              initialisation, and you might want to do different things depending on
     *              the context. For most applications, they initialise data if and only if
     *              gridIsConstructed holds, but others might also initialise data throughout
     *              the construction to guide AMR criteria.
     *
     */
    virtual void initialCondition(
      {{SOLUTION_STORAGE_PRECISION}}* __restrict__                          Q,     // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const tarch::la::Vector<Dimensions,double>&  x,
			const tarch::la::Vector<Dimensions,double>&  h,
			const tarch::la::Vector<Dimensions,int>&     index,
      bool                                         gridIsConstructed
    ) {% if INITIAL_CONDITIONS_IMPLEMENTATION=="<user-defined>" %}= 0{% else %} final {% endif %};


    /**
     * Apply boundary conditions. You can overwrite both the inside and
     * outside values though most BCs only modify the outside ones. Please
     * note that the boundary conditions you set here are after that subject
     * to the Riemann solver, i.e. flux and eigenvalues.
     *
     * \param[in]    x         the physical coordinate on the face.
     * \param[in]    t         the start of the time interval.
     * \param[in]    dt        the width of the time interval.
     * \param[in]    faceIndex indexing of the face (0 -- {x[0]=xmin}, 1 -- {x[1]=xmax}, 2 -- {x[1]=ymin}, 3 -- {x[2]=ymax}, and so on,
     *                         where xmin,xmax,ymin,ymax are the bounds of the cell containing point x.
     * \param[in]    d         the coordinate direction the face normal is pointing to.
     * \param[in]    QIn       the conserved variables at point x from inside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[in]    FIn       the normal fluxes at point x from inside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[inout] QOut      the conserved variables at point x from outside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     * \param[inout] FOut      the normal fluxes at point x from outside of the domain
     *                         and time-averaged (over [t,t+dt]) as C array (already allocated).
     */
    virtual void boundaryConditions(
      const {{CORRECTOR_COMPUTATION_PRECISION}} * __restrict__                  Qinside, // Qinside[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      {{CORRECTOR_COMPUTATION_PRECISION}} * __restrict__                        Qoutside, // Qoutside[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const tarch::la::Vector<Dimensions,double>&  faceCentre,
      const tarch::la::Vector<Dimensions,double>&  volumeH,
      double                                       t,
      int                                          normal
    ){% if BOUNDARY_CONDITIONS_IMPLEMENTATION=="<user-defined>" %}= 0{% else %} final{% endif %};

    {% if ADAPTIVE_PRECISION_IMPLEMENTATION!="<none>" %}
    /**
     * Evaluate precision criterion over cell
     *
     * @param Q             Vector of unknowns
     * @param x             Centre of underlying cell
     * @param h             Size of underlying cell
     * @param t             Time
     * @param currentState  State of the solver at time of calling
     */
    virtual ::exahype2::PrecisionCommand precisionCriterion(
      const {{SOLUTION_STORAGE_PRECISION}} * __restrict__ Q, // Q[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const tarch::la::Vector<Dimensions,double>&         x,
      const tarch::la::Vector<Dimensions,double>&         h,
      double                                              t,
      SolverState                                         currentState
    ) {% if ADAPTIVE_PRECISION_IMPLEMENTATION=="<user-defined>" %} = 0{% else %} final {% endif %};
    {% endif %}

    {% if RIEMANN_SOLVER_IMPLEMENTATION!="<none>" %}
    /**
     * Evaluate precision criterion over cell
     *
     * @param Q             Vector of unknowns
     * @param x             Centre of underlying cell
     * @param h             Size of underlying cell
     * @param t             Time
     * @param currentState  State of the solver at time of calling
     */
    virtual void riemannSolver(
      {{CORRECTOR_COMPUTATION_PRECISION}}* const FL, // FL[{{NUMBER_OF_UNKNOWNS}}
      {{CORRECTOR_COMPUTATION_PRECISION}}* const FR, // FR[{{NUMBER_OF_UNKNOWNS}}
      const {{CORRECTOR_COMPUTATION_PRECISION}}* const QL, // QL[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const {{CORRECTOR_COMPUTATION_PRECISION}}* const QR, // QR[{{NUMBER_OF_UNKNOWNS}}+{{NUMBER_OF_AUXILIARY_VARIABLES}}]
      const double t,
      const double dt, 
      const tarch::la::Vector<Dimensions, double>& x,
      const tarch::la::Vector<Dimensions, double>& h,
      const int direction, 
      bool isBoundaryFace, 
      int faceIndex) {% if RIEMANN_SOLVER_IMPLEMENTATION=="<user-defined>" %} = 0{% else %} final {% endif %};
    {% endif %}

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startGridConstructionStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishGridConstructionStep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startGridInitialisationStep() override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishGridInitialisationStep() override;


    virtual void suspendSolversForOneGridSweep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishTimeStep() override;


    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void startPlottingStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) override;

    /**
     * If you hook into this routine, ensure the abstract base class
     * operation is still invoked.
     */
    virtual void finishPlottingStep() override;


    /**
     * @param currentTimeStep If you set this to false, you'll get the
     *   quantity from the preceding time step. This is important for
     *   local time stepping with fixed subcycling, as they have to
     *   know the sizes from the last time step throughout the traversal,
     *   where the current patch size might just be re-evaluated.
     *
     * @return Actually observed sizes, not the admissible quantities
     */
    double getMaxCellSize(bool currentTimeStep = true) const;
    double getMinCellSize(bool currentTimeStep = true) const;

    /**
     * Within the DG context, mesh is an alias for cell.
     */
    virtual double getMaxMeshSize() const override final;
    virtual double getMinMeshSize() const override final;
    
    /**
     * Functions inherited from Solver.h in the aderdg context, these provide
     * information to ExaSeis expansions
     *
     * @todo Should not be here
     */    
    virtual tarch::la::Vector<Dimensions,double> getDomainSize()    const override final;
    virtual tarch::la::Vector<Dimensions,double> getDomainOffset()  const override final;
    virtual double getCoarsestMeshSize()                            const override final;
    virtual int getCoarsestMeshLevel()                              const override final;
    virtual int getMaximumAdaptiveMeshLevel()                       const override final;
    virtual int getMaximumAdaptiveMeshDepth()                       const override final;
    

    /**
     * Update the global solver state, i.e. inform the solver about some
     * updated global quantities.
     *
     * @see setTimeStepSize(double)
     */
    void update(double timeStepSize, double timeStamp, double cellSize);

    SolverState  getSolverState() const;

    /**
     * Always holds.
     */
    virtual bool mayPlot() const override;

    /**
     * This predicate is always true, as we work with a single-sweep
     * implementation, i.e. each grid sweep realises one time step.
     */
    bool isFirstGridSweepOfTimeStep() const;
    bool isLastGridSweepOfTimeStep() const;

    /**
     * Feel free to overwrite in user code, but ensure the superclass
     * implementation is still invoked, too.
     */
    virtual void startSimulation() override;

    /**
     * Feel free to overwrite in user code, but ensure the superclass
     * implementation is still invoked, too.
     */
    virtual void finishSimulation() override;



  protected:
    static tarch::logging::Log  _log;

    SolverState  _solverState;

    double     _minTimeStamp;
    double     _maxTimeStamp;

    double     _minTimeStampThisTimeStep;
    double     _maxTimeStampThisTimeStep;

    double     _localMinTimeStampThisTimeStep;
    double     _localMaxTimeStampThisTimeStep;

    double     _minCellH;
    double     _maxCellH;

    double     _minCellHThisTimeStep;
    double     _maxCellHThisTimeStep;

    double     _minTimeStepSize;
    double     _maxTimeStepSize;

    double     _minTimeStepSizeThisTimeStep;
    double     _maxTimeStepSizeThisTimeStep;

    int        _cellUpdates;

    tarch::multicore::BooleanSemaphore  _semaphore;


  {{ABSTRACT_SOLVER_USER_DECLARATIONS}}
};


