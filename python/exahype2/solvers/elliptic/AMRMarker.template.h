// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once


#include "exahype2/RefinementControl.h"
#include "exahype2/Solver.h"

#include "tarch/la/Vector.h"
#include "tarch/multicore/BooleanSemaphore.h"

#include "peano4/utils/Globals.h"

#include "Constants.h"


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



class {{NAMESPACE | join("::")}}::{{CLASSNAME}}: public ::exahype2::Solver {
  public:
    /**
     * We do not impose any constraints on the patch/cell size.
     */
    static constexpr double MaxAdmissibleCellH  = std::numeric_limits<double>::max();
    static constexpr double MinAdmissibleCellH  = 0.0;

    {{CLASSNAME}}();

    /**
     * Alias for periodic boundary conditions.
     */
    static std::bitset<Dimensions> PeriodicBC;

    /**
     * Infinity, as we do not restrict anything.
     */
    double getMinTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;
    double getMaxTimeStamp(bool ofCurrentlyRunningGridSweep=false) const final;


    double getMinTimeStepSize() const final;
    double getMaxTimeStepSize() const final;

    /**
     * Nop
     */
    void startGridConstructionStep() final;
    void finishGridConstructionStep() final;
    void startGridInitialisationStep() final;
    void finishGridInitialisationStep() final;
    void startTimeStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) final;
    void finishTimeStep() final;
    void startPlottingStep(
      double globalMinTimeStamp,
      double globalMaxTimeStamp,
      double globalMinTimeStepSize,
      double globalMaxTimeStepSize
    ) final;
    void finishPlottingStep() final;

    virtual double getMaxMeshSize() const override final;
    virtual double getMinMeshSize() const override final;

    virtual bool mayPlot() const override;

    virtual void startSimulation() override;
    virtual void finishSimulation() override;

    /**
     * By construction, we always are in the first and last sweep of time
     * step. Logically, each individual sweep is a time step.
     */
    bool isFirstGridSweepOfTimeStep() const;
    bool isLastGridSweepOfTimeStep() const;
  protected:
    static tarch::logging::Log  _log;
};



{# Empty line here #}
