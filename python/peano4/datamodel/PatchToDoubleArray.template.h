// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#pragma once

#include <string>

#include "tarch/la/Vector.h"
#include "tarch/mpi/mpi.h"
#include "tarch/compiler/CompilerSpecificSettings.h"

#include "peano4/utils/Globals.h"
#include "peano4/grid/grid.h"

#include "peano4/datamanagement/CellMarker.h"
#include "peano4/datamanagement/FaceMarker.h"
#include "peano4/datamanagement/VertexMarker.h"
#include "peano4/grid/TraversalObserver.h"




{% if FLOAT_TYPE=="std::float16_t" or FLOAT_TYPE=="std::bfloat16_t" %}
#include <stdfloat>
{% endif %}

{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}

  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}


{{INCLUDES}}



struct {{NAMESPACE | join("::")}}::{{CLASSNAME}} {
  #if Parallel
  private:
    static MPI_Datatype   Datatype;
  public:
  #endif
  #if PeanoDebug>=1
  private:
    tarch::la::Vector<Dimensions,double> _debugX;
    tarch::la::Vector<Dimensions,double> _debugH;


  public:
    void setDebugX( const tarch::la::Vector<Dimensions,double>& data );
    void setDebugH( const tarch::la::Vector<Dimensions,double>& data );
    tarch::la::Vector<Dimensions,double> getDebugX() const;
    tarch::la::Vector<Dimensions,double> getDebugH() const;
  #endif

  #if Dimensions==2
  alignas(AlignmentOnHeap) {{FLOAT_TYPE}}                                 value[{{CARDINALITY_2D}}];
  #else
  alignas(AlignmentOnHeap) {{FLOAT_TYPE}}                                 value[{{CARDINALITY_3D}}];
  #endif
  
  enum ObjectConstruction {
    NoData
  };

  {{CLASSNAME}}();
  {{CLASSNAME}}( ObjectConstruction ):
    {{CLASSNAME}}() {}
  {{CLASSNAME}}(const {{CLASSNAME}}& other);
  {{CLASSNAME}}& operator=(const {{CLASSNAME}}& other);

  std::string toString() const;
  
  {% if DATA_ASSOCIATION == 1 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::VertexMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}

  {% if DATA_ASSOCIATION == 2 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::FaceMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}

  {% if DATA_ASSOCIATION == 3 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::CellMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}
  
  #ifdef Parallel
  /**
   * Initialises the MPI datatype.
   */
  static void initDatatype();

  /**
   * Free MPI datatype.
   */
  static void shutdownDatatype();
  
  /**
   * Map each entry to an MPI_DOUBLE. So we will end up with three
   * arrays of doubles: one for the x, one for the size of the
   * patchy data, and one for the actual data. This holds for the
   * debug mode. In release mode, it is the plain data only, i.e.
   * one sequence of doubles.
   */
  static MPI_Datatype  getForkDatatype();
  static MPI_Datatype  getJoinDatatype();
  static MPI_Datatype  getBoundaryExchangeDatatype();
  static MPI_Datatype  getMultiscaleDataExchangeDatatype();
  static MPI_Datatype  getGlobalCommunciationDatatype();
  #endif
};
