//
// Peano4 data file
// Generated by Peano's Python API
// www.peano-framework.org
// This is generated. Be careful with adding your own stuff
//
#pragma once



#include <string>
#include <memory>


#include "tarch/la/Vector.h"
#include "tarch/mpi/mpi.h"

#include "peano4/utils/Globals.h"
#include "peano4/grid/LoadStoreComputeFlag.h"

#include "peano4/datamanagement/CellMarker.h"
#include "peano4/datamanagement/FaceMarker.h"
#include "peano4/datamanagement/VertexMarker.h"
#include "peano4/grid/TraversalObserver.h"

{% if FLOAT_TYPE=="std::float16_t" or FLOAT_TYPE=="std::bfloat16_t" %}
#include <stdfloat>
{% endif %}


{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}

  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}


{{INCLUDES}}



struct {{NAMESPACE | join("::")}}::{{CLASSNAME}} {
  private:
    #if Parallel
    static MPI_Datatype   Datatype;
    #endif

    #if PeanoDebug>=1
    tarch::la::Vector<Dimensions,double> _debugX;
    tarch::la::Vector<Dimensions,double> _debugH;
    #endif

    /**
     * Pointer to array.
     *
     * We have to use double[] here for example to be C++ conformal. This still
     * means that _dataSmartPointer is only one pointer. See
     *
     * https://www.nextptr.com/question/qa1348405750/dynamic-array-with-stdunique_ptr
     *
     * for an example.
     */
    std::shared_ptr< {{FLOAT_TYPE}}[] > _dataSmartPointer;
  public:
    typedef {{FLOAT_TYPE}} DoFType;

    /**
     * @see peano4::stacks::STDVectorStackOverSmartPointers<T>::pushBlock()
     */
    enum ObjectConstruction {
      NoData
    };

    #if Dimensions==2
    static constexpr int Cardinality = {{CARDINALITY_2D}};
    #else
    static constexpr int Cardinality = {{CARDINALITY_3D}};
    #endif

    #if PeanoDebug>=1
    void setDebugX( const tarch::la::Vector<Dimensions,double>& data );
    void setDebugH( const tarch::la::Vector<Dimensions,double>& data );
    tarch::la::Vector<Dimensions,double> getDebugX() const;
    tarch::la::Vector<Dimensions,double> getDebugH() const;
    #endif

  /**
   * This is an alias to the actual data stored within _dataSmartPointer. We
   * need this alias, as a lot of code snippets in Peano work with raw pointers
   * including pointer arithmetics. The latter are not supported by smart
   * pointers. SO the actual data is held via the smart pointer, but the
   * content can also be accessed through this attribute.
   */
  {{FLOAT_TYPE}}*   value;
  

  /**
   * Create new instance
   *
   * The routine creates a new smart pointer data set and then sets the value
   * pointer to the smart pointer's raw data. It does not set the debug values,
   * which you have to initialise separately.
   *
   * This routine is used by all creational events, i.e. create a vertex for
   * example uses it as well as create a hanging vertex.
   *
   *
   * ## Implementation
   *
   * The constructor requires us to pass in a pointer to the actual array, and
   * then the constructor will wrap that in the smart pointer meta data structures.
   *
   * Since I use a user-defined allocator (which might take care of all
   * alignment, e.g.), I also have to provide a user-defined free. These two
   * should match. By default, the smart pointer uses
   *
   *       delete[] p;
   *
   * and that's not what we want here.
   *
   *
   * Further information can be found at
   * https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr.
   */
  {{CLASSNAME}}();

  /**
   * Constructor that does not allocate the underlying memory
   *
   * We need such a variant in stacks to allocate large memory blocks which
   * are then "overwritten" as we move data from one stack to the other.
   *
   * @see peano4::stacks::STDVectorStackOverSmartPointers<T>::pushBlock()
   */
  {{CLASSNAME}}( ObjectConstruction );

  /**
   * Nothing really to be done, as the smart pointer implementation takes
   * care of the actual destruction.
   */
  ~{{CLASSNAME}}() = default;

  /**
   * Copy constructor
   *
   * In most cases, this should be a shallow copy. We move data around from
   * one stack to the other and we do so via the copy constructor. This
   * moving around equals a shallow copy. The smart pointer behind the scenes
   * can basically realise the shallow part. We only have to copy this one,
   * and then set the local value pointer to the smartish memory regions.
   *
   * Besides the shallow copies, the copy also is used when we do a resize()
   * on the underlying stack. In this case, it is unreasonable to copy the
   * smart pointer. See peano4::stacks::STDVectorStackOverSmartPointers<T>::pushBlock().
   */
  {{CLASSNAME}}(const {{CLASSNAME}}& other);

  /**
   * Clone content.
   *
   * This routine is used by the spacetree to copy
   * data from an outgoing buffer into an incoming or an MPI buffer. This is
   * required when we stream a tree to another tree, or whenever we exchange
   * data along the MPI boundary. Consult
   * peano4::parallel::SpacetreeSet::exchangeAllHorizontalDataExchangeStacks()
   * for example.
   *
   * Therefore, the destination should always be empty. Otherwise, something
   * went terribly wrong: The receiving side otherwise hasn't really processed
   * all data handled in and we likely encounter an inconsistent global state.
   *
   * We however do not know if the
   * input data other is empty or not: We always exchange all boundary
   * unknown types, but if a solver is localised, it might actually never
   * write into an outgoing buffer. Therefore, other might be empty.
   *
   * If other is not empty, we have to perform a deep copy.
   */
  void clone(const {{CLASSNAME}}& other);

  std::shared_ptr< {{FLOAT_TYPE}}[] > getSmartPointer() const;

  /**
   * Shallow copy
   */
  {{CLASSNAME}}& operator=(const {{CLASSNAME}}& other);

  std::string toString() const;
  
  {% if DATA_ASSOCIATION == 1 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::VertexMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::VertexMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}

  {% if DATA_ASSOCIATION == 2 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::FaceMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::FaceMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}

  {% if DATA_ASSOCIATION == 3 -%}
  void merge(peano4::grid::TraversalObserver::SendReceiveContext context, const {{CLASSNAME}}& neighbour, const peano4::datamanagement::CellMarker& marker, int spacetreeId);
  bool send(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  bool receiveAndMerge(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  ) const;
  static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(
    const peano4::datamanagement::CellMarker& marker
    {% for arg in ADDITIONAL_LOAD_STORE_ARGUMENTS %}, const {{arg[1]}}& {{arg[2]}} {% endfor %}
  );
  {% endif -%}
  
  
  
  #ifdef Parallel
  /**
   * Initialises the MPI datatype.
   */
  static void initDatatype();

  /**
   * Free MPI datatype.
   */
  static void shutdownDatatype();
  
  /**
   * Different to the vanilla version of the patch to double mapping, the datatype here
   * does never (!) include any meta data.
   */
  static MPI_Datatype  getForkDatatype();
  static MPI_Datatype  getJoinDatatype();
  static MPI_Datatype  getBoundaryExchangeDatatype();
  static MPI_Datatype  getMultiscaleDataExchangeDatatype();
  static MPI_Datatype  getGlobalCommunciationDatatype();
  #endif
};


