//
// Peano4 data file
// Generated by Peano's Python API
// www.peano-framework.org
// This is generated. Be careful with adding your own stuff
//
#pragma once


#include <{{STD_CONTAINER}}>
#include <list>

#include "tarch/logging/Log.h"
#include "tarch/la/Vector.h"
#include "tarch/mpi/mpi.h"

#include "peano4/utils/Globals.h"
#include "peano4/datamanagement/VertexMarker.h"
#include "peano4/grid/TraversalObserver.h"

#include "toolbox/particles/ParticleSet.h"


{% for item in NAMESPACE -%}
  {% if not loop.last %}
  namespace {{ item }} {
  {% endif %}
{%- endfor %}

  namespace globaldata {
    class {{PARTICLE_TYPE}};
  }
{% for item in NAMESPACE -%}
  {% if not loop.last %}
  }
  {% endif %}
{%- endfor %}



{% for item in NAMESPACE -%}
  namespace {{ item }} {
{%- endfor %}


  class {{CLASSNAME}}: public toolbox::particles::ParticleSet< {% for item in NAMESPACE -%}{% if not loop.last %}{{ item }}::{% endif %}{%- endfor %}globaldata::{{PARTICLE_TYPE}} >
                       {
    public:
      using Base      = toolbox::particles::ParticleSet< {% for item in NAMESPACE -%}{% if not loop.last %}{{ item }}::{% endif %}{%- endfor %}globaldata::{{PARTICLE_TYPE}} >;
      using Container = std::{{STD_CONTAINER}}< {% for item in NAMESPACE -%}{% if not loop.last %}{{ item }}::{% endif %}{%- endfor %}globaldata::{{PARTICLE_TYPE}}* >;

      /**
       * Expose C++ standard interface
       */
      typedef Container::value_type      value_type;
      typedef Container::iterator        iterator;
      typedef Container::const_iterator  const_iterator;

      {{CLASSNAME}}() = default;


      enum ObjectConstruction {
        NoData
      };

      {{CLASSNAME}}( ObjectConstruction ):
        {{CLASSNAME}}() {}

      /**
       * Shallow copy constructor
       *
       * There's no need to redefine this one. I just wanted to highlight
       * that it is a shallow copy, i.e. to add a comment, and so I
       * "overwrote" it.
       *
       * Please consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" for
       * further context.
       */
      {{CLASSNAME}}( const {{CLASSNAME}}& ) = default;

      /**
       * Merge two particle sets
       *
       * Please consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" before
       * you study the implementation remarks below. Furhermore, consult the
       * documentation of peano4.toolbox.particles.api.UpdateParallelState which
       * provides some examples of the functionality added here.
       *
       * @see STDVectorOverContainerOfPointers::startReceive()
       * @see clone()
       */
      void merge(::peano4::grid::TraversalObserver::SendReceiveContext context, {{CLASSNAME}}& neighbour, const peano4::datamanagement::VertexMarker& marker, int spacetreeId);

      static bool send(const peano4::datamanagement::VertexMarker& marker);
      static bool receiveAndMerge(const peano4::datamanagement::VertexMarker& marker);
      static ::peano4::grid::LoadStoreComputeFlag loadStoreComputeFlag(const peano4::datamanagement::VertexMarker& marker);

      /**
       * Deep clone
       *
       * Please consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" before
       * you study the implementation remarks below.
       *
       * @see STDVectorOverContainerOfPointers() for a description of the
       *   intra-node parallelisation. This description provides an overview
       *   of the overall lifecycle of the data.
       * @see merge() for the corresponding delete that eliminates the deep
       *   copies.
       */
      void clone( const {{CLASSNAME}}& otherSet );

      std::string toString() const;

      /**
       * Mark whole particle set as set of particles which can't be lifted
       *
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       *
       * The operation runs over all hosted particles and invokes
       * particleCanNotBeLiftedLocally() per particle.
       */
      void particlesCanNotBeLiftedLocally();

      void particlesCanNotBeDroppedLocallySoRollOverForNextMeshSweep(DoFType*  particle);

      /**
       * Shallow clear
       *
       * Plain delegate to superclass clear(), i.e. this routine clears a set
       * of pointers, but it does not delete the actual particles. If you want
       * that behaviour, you have to call deleteParticles(). I merely introduce
       * this wrapper to be able to add this comment on the shallow vs deep
       * copy/clear mechanism.
       *
       * There's no need to redefine this one. I just wanted to highlight
       * that it is a shallow copy, i.e. to add a comment, and so I
       * "overwrote" it.
       */
      void clear();

      /**
       * Inform set that particle cannot be lifted on its current tree
       *
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       */
      Container::iterator particleCanNotBeLiftedLocally( const Container::iterator&   particle );

      /**
       * This is a deep delete
       *
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       */
      void deleteParticles();

      /**
       * Expose the STD container partially
       *
       * The fact that you hold a const or non-const iterator does not mean that
       * you are ever allowed to delete a particle. That has to be done through
       * the corresponding deleteParticle() operation.
       *
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       */
      Container::iterator begin();
      Container::iterator end();
      Container::const_iterator begin() const;
      Container::const_iterator end() const;
      int size() const;

      /**
       * Add one particle
       *
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       *
       * This routine does not copy the particle. It adds the references
       * (pointer) to the particle only. Notably, this routine does not
       * give the set exclusive ownership of the particle.
       *
       * Is internally mapped onto a push_back.
       */
      void addParticle(DoFType* particle);

      /**
       * Some simple validation
       *
       * I run some simple validations such as: does every particle have a
       * valid parallel state. This might result in the detection of memory
       * garbage. The routine is typically used within assertions.
       */
      bool isValid() const;

      /**
       * Moves particles from one particle set to the other
       *
       * This is used by the multiscale algorithm
       */
      void grabParticles({{CLASSNAME}}& sourceParticleSet);

      /**
       * Move particle from one container to the other one
       *
       * @return Iterator within sourceParticleSet which is returned after
       *   erasing it from this set.
       */
      Container::iterator grabParticle(
        const Container::iterator&         particle,
        {{CLASSNAME}}&                     sourceParticleSet
      );

      /**
       * Delete a particle
       *
       * Should be used, for example, if a particle has left the local domain.
       * Consult @ref toolbox_particles_memorypool "the generic discussion of the particle memory management" as well as the documentation of toolbox::particles::ParticleSet for
       * some context and references to other routines.
       * 
       * @return an iterator to the particle. This iterator is robust, i.e. even 
       *   if we have altered the underlying data, this one is still valid. It is
       *   however not efficient, i.e. it might point to begin() and any outer
       *   loop hence might restart to run over all particles again. 
       */
      Container::iterator deleteParticle( const Container::iterator&   particle );

      /**
       * Extracted into routine of its own
       *
       * This routine it used by boundary merges, periodic boundary merges, and
       * also drops.
       *
       * ## Debug data
       *
       * Even if we replace a current particle with an incoming one, we keep
       * the current particle's (debug) location. This way, we ensure that all
       * debug data remain correct also for periodic BCs.
       *
       * @param neighbourParticle Will either be incorporated into current data
       *   structure or the routine will delete it if it decides not to use
       *   the object the pointer points to.
       */
      void mergeWithParticle(
        DoFType*                                     neighbourParticle,
        const peano4::datamanagement::VertexMarker&  marker,
        int                                          spacetreeId
      );
    private:
      static tarch::logging::Log _log;

      Container  _container;
};

{% for item in NAMESPACE -%}
}
{%- endfor %}


