// This file is part of the ExaHyPE2 project. For conditions of distribution and
// use, please see the copyright notice at www.peano-framework.org
#pragma once


#include <vector>

#include "tarch/la/la.h"
#include "tarch/la/Vector.h"
#include "tarch/multicore/multicore.h"
#include "tarch/Assertions.h"

#include "peano4/grid/GridControlEvent.h"
#include "peano4/datamanagement/CellMarker.h"
#include "peano4/utils/Globals.h"
#include "peano4/utils/Loop.h"

#include "Functors.h"

#include "exahype2/fv/PatchUtils.h"



namespace exahype2 {
  namespace dg {
    /**
     * Construct location of a quadrature point
     *
     * Given the centre of a cell as well as the size of this cell plus the
     * index of a quadrature point, the underlying polynomial order and the 1d
     * spacing of the points on the reference element, this function
     * computes the spatial position of a quadrature node.
     *
     * For example if there are 2 points in each dimension, located at [0.25,0.75]
     * in 1d, then for a 2d cell with center 0.5 and size 1 [i.e. ranging from [0,0]
     * to [1,1], there would be four nodes specified with indexes 0 to 3 and respective
     * positions [0.25,0.25], [0.25,0.75], [0.75,0.25] and [0.75,0.75]
     *
     * @param polynomialOrder order of the underlying polynomial, this specifies
     * the number of quadraturePoints in each direction as order+1
     *
     * @param quadraturePoints 1d quadrature points over unit interval. This array
     *                         has polynomialOrder+1 entries. See the documentation
     *                         of the Python class exaype2.solvers.LagrangeBasis (use search field in the webpage generated by doxygen).
     */
    tarch::la::Vector<2,double>  getQuadraturePoint(
      const tarch::la::Vector<2,double>&  cellCentre,
      const tarch::la::Vector<2,double>&  cellSize,
      const tarch::la::Vector<2,int>&     index,
      int                                 polynomialOrder,
      const double* __restrict__          quadraturePoints
    );


    /**
     * 3d cousin of the 2d getQuadraturePoint() routine.
     */
    tarch::la::Vector<3,double>  getQuadraturePoint(
      const tarch::la::Vector<3,double>&  cellCentre,
      const tarch::la::Vector<3,double>&  cellSize,
      const tarch::la::Vector<3,int>&     index,
      int                                 polynomialOrder,
      const double* __restrict__          quadraturePoints
    );

    /**
     * Compute integral over shape function over cell defined by index
     *
     * @param cellSize  Size of the cell hosting the polygonials.
     *   This vector determines the scaling, i.e. the @f$ h^d @f$
     *   factor, of the outcome.
     * @param index     Determine the quadrature point within the cell
     *   that is to be evaluated.
     * @param quadratureWeights    Array of the weights of a 1d shape
     *   function, i.e. the outcome of the 1d integral. As we work with
     *   a tensor product approach, we can evaluate each direction
     *   independently.
     */
    double  getQuadratureWeight(
      const tarch::la::Vector<3,double>&  cellSize,
      const tarch::la::Vector<3,int>&     index,
      const double* __restrict__          quadratureWeights
    );


    /**
     * The number of nodes in a cell is basically the input to the
     * power of d. The argument nodesPerAxis is typically the order
     * plus one.
     *
     * @return Number of nodes in a cell
     */
    int getNodesPerCell(int nodesPerAxis);


    /* returns a vector with the powers of nodesPerAxis up to the Dimensions - 1
    ** e.g. for dims = 2, nodesPerAxis = 2 will return (1, 2)
    **      for dims = 3, nodesPerAxis = 4 will return (1, 4, 16)
    **
    ** This is used to iterate over the nodes of a cell in a given dimension,
    ** since the cells are all in the same array one after another advancing by
    ** n*strides[i] will move you to the cell which is n steps in direction i
    ** from the current cell.
    ** i.e. node+1 would be the "right" neighbour, node+nodesPerAxis would be the
    ** "upper" neighbour, and so on.
    */
    tarch::la::Vector<Dimensions,int> getStrides(int nodesPerAxis);


    /*for a given linear node number, returns the index of that node
    **in cartesian coordinate system.
    **e.g. for dims = 2, nodesPerAxis = 4, there will be 16 total nodes
    **  so node 0 is [0,0], 1 is [1,0] and so on until 15 which is [3,3]
    **     for dims = 3, nodesPerAxis = 4, there will be 16*4 = 64 total nodes
    **     ranging from 0 which is [0,0,0] to 63 which is [3,3,3]
    */
    tarch::la::Vector<Dimensions,int> getIndex(
        int                                node,
        tarch::la::Vector<Dimensions,int>  strides
    );

    /*
     * for a given node index within the cell, returns the index of the neighbouring
     * node on the surface in a given direction with a given orientation.
     *
     * Ordering on the surface is the same as for the previous functions, but only
     * considering one "side" on each face
     *
     * So with the same notation as the previous function, if given a 2*2 cell
     * in 2 dimensions, there are a total of 4 faces (left,right,down,up), each
     * with 2 nodes.
     * If given index which corresponds to [0,1],
     *   direction 0, orientation 0 would return node 1 on the left face
     *   direction 1, orientation 1 would return node 0 on the upper face
     *       6 7
     *   1 [ o o ] 3
     *   0 [ o o ] 2
     *       4 5
     */
    int cellIndexToHullIndex(
        const tarch::la::Vector<Dimensions,int>&  indexCell,
        const int                                 direction,
        const int                                 orientation,
        const int                                 nodesPerAxis
        );

    /*
     * Computes the gradient of Q in a given direction for a given node
     *
     * Mostly used for the non-conservative product.
     *
     * Since the solution is represented by the sum of basis functions, its
     * derivative at a given node is the sum of the derivatives of the basis
     * functions evaluated at that node.
     * The derivative operator contains the value of the derivatives evaluated
     * at the quadrature nodes, therefore it only needs to be multiplied by
     * their coefficients.
     *
     *
     * u(x) = \sum_i \phi_i(x) * u_i => du(x)/dx = d\phi_i(x_i)/dx * u_i
     *
     * @param invDx: the inverse of the size of the cell in any one dimension, this
     * assumes that the cells are cubic
     *
     * @param derivativeOperator: array containing the value of the derivatives of
     * the n base functions of the dg polynomial evaluated at the n quadrature points
     * (in 1 dimension)
     *
     * @param scalarIndex: index of the node at which the gradient should be evaluated
     *
     * @param gradQ: where the gradient values should be placed, has size unknowns*Dimensions
     * since there is a gradient in each direction and the gradient is only nonzero for the
     * unknowns
     *
     * @param strideQ: total number of variables over which the gradient should be computed
     */
    void computeGradient(
        const double* __restrict__ const QCell,
        const double* __restrict__ const derivativeOperator,
        const double                     invDx,
        const int                        nodesPerAxis,
        const int                        strideQ,
        const int                        scalarIndex,
        double* __restrict__             gradQ
        );

    /*
     * Substracts contents of one cell array from another.
     */
    void subtractCell(
        double* __restrict__        QOut,
        const double* __restrict__  Qsubstract,
        const int                   order,
        const int                   unknowns,
        const int                   auxiliaryVariables
        );


    /*
     * Plot patch
     *
     * usually used for debugging
     */

    std::string plotCell(
        const double* __restrict__ Q,
        const int order,
        const int unknowns,
        const int auxiliaryVariables
    );

    /*
     * Plot Face
     *
     * Usually used for debugging. We plot all unknowns, i.e. both the unknowns
     * form the left and the right adjacent side. The order is linear, i.e. you
     * have to take the normal into account when you want to find out how the
     * unknowns are spatially arranged.
     *
     * See the discussion around ExaHyPE's lexicographic ordering.
     */
    std::string plotFace(
      const double* __restrict__ Q,
      const int order,
      const int unknowns,
      const int auxiliaryVariables,
      int       normal,
      int       numberOfQuantitiesProjectedOntoFace
    );

    /**
     * Evaluate the DG polynomial
     *
     * Evaluate the Lagrangian polynomial within the cell specified by marker in
     * one point. Return the value unknown within this interpolated point.
     *
     * ## Realisation
     *
     * We loop with a d-dimensional for loop over all quadrature points within
     * the cell. Each iteration of this loop over currentDoF evalutes the impact
     * of the polynomial anchored at currentDoF onto the position of interest.
     * To find out what this polynomial looks like, we have to loop over all
     * quadrature points again, besides those guys that coincide in one
     * coordinate with the shape function at currentDoF. This inner loop over
     * quadraturePoint exploits the fact that the Lagrange polynomials are
     * constructed through a product over terms, while the overall d-dimensional
     * shape function results from a tensor product. Therefore, we can evaluate
     * the shape function over one big loop multiplying the enumerator and
     * denominator.
     *
     * Once the shape function's value at point x is evaluated, we multiple it
     * with the actual weight of this function. The outcome is added to the
     * result, as we work with a standard nodal basis.
     *
     * @param marker         Marker that specifies the cell, i.e. its size and
     *   offset.
     * @param order          Order of the polynomial.
     * @param QuadratureNodes1d  Arrangement of the quadrature points on the 1d
     *   unit interval, i.e. from 0 to 1.
     * @param unknownsPerDoF Total number of unknowns within a degree of
     *   freedom. Shoudl incorporate the number of material parameters.
     * @param Q              Pointer to data stored as AoS. The size of this
     *   data field is @f$ (order+1)^d \cdot unknownsPerDoF @f$.
     * @param x              Point of interest where the overall polynomial
     *   solution is to be evaluated.
     * @param unknown        Unknown of interest.
     */
    template<typename QStoreType>
    QStoreType evaluatePolynomial(
      const peano4::datamanagement::CellMarker&    marker,
      int                                          order,
      const double* __restrict__                   QuadratureNodes1d,
      int                                          unknownsPerDoF,
      const QStoreType* __restrict__               Q,
      const tarch::la::Vector<Dimensions,double>&  x,
      int                                          unknown
    );

    /**
     * Delegate to PatchUtils of the Finite Volume scheme
     */
    void copyOneSideOfFaceProjection(
      int    unknownsPlusAuxiliaryVariables,
      int    order,
      int    numberOfProjectedQuantities,
      int    normal,
      int    isRightFaceHalf,
      const double* __restrict__   srcQ,
      double* __restrict__         destQ
    );
  }
}


#include "DGUtils.cpph"