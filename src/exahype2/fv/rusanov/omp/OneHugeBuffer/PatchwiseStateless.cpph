// This file is part of the ExaHyPE2 project. For conditions of distribution and
// use, please see the copyright notice at www.peano-framework.org


namespace exahype2::fv::rusanov::omp::internal {

template <
  class SolverType,
  int  NumberOfVolumesPerAxisInPatch,
  int  HaloSize,
  int  NumberOfUnknowns,
  int  NumberOfAuxiliaryVariables,
  bool EvaluateFlux,
  bool EvaluateNonconservativeProduct,
  bool EvaluateSource,
  bool EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType,
  int IterationsPerTransfer
>
void timeStepWithRusanovPatchwiseStatelessOneHugeBuffer(
    int targetDevice, 
    GPUCellData& gpuPatchData,
    double*       tempFluxX,
    double*       tempFluxY,
    double*       tempFluxZ,
    double*       tempNonconservativeProductX,
    double*       tempNonconservativeProductY,
    double*       tempNonconservativeProductZ,
    double*       tempEigenvalueX,
    double*       tempEigenvalueY,
    double*       tempEigenvalueZ
)
{
    const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const TempDataEnumeratorType                  fluxEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  ncpEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch + 1, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  eigenvalueEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, 1, 0);

    const int numberOfCells = gpuPatchData.numberOfCells;
    const ::tarch::la::Vector<Dimensions, double>* rawPointerToCellCentre = gpuPatchData.cellCentre;
    const ::tarch::la::Vector<Dimensions, double>* rawPointerToCellSize = gpuPatchData.cellSize;
    // const double* rawPointerToCellCentre = gpuPatchData.cellCentre[0].data();
    // const double* rawPointerToCellSize = gpuPatchData.cellSize[0].data();
    const double* t = gpuPatchData.t;
    const double* dt = gpuPatchData.dt;
    double* maxEigenvalue = gpuPatchData.maxEigenvalue;
    const double* const* mappedPointersToQIn = gpuPatchData.QIn;
    double** mappedPointersToQOut = gpuPatchData.QOut;

#pragma omp target teams distribute device(targetDevice) firstprivate(QInEnumerator, QOutEnumerator, fluxEnumerator, ncpEnumerator, eigenvalueEnumerator) // nowait
    for (int patchIndex = 0; patchIndex < numberOfCells; patchIndex++) {
      // ====================================================
      // Copy solution over and evaluate source (if required)
      // ====================================================
      if constexpr (EvaluateSource) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::copySolutionAndAddSourceTerm<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y),
              t[patchIndex],
              dt[patchIndex],
              mappedPointersToQOut[patchIndex],
              QOutEnumerator
            );
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::copySolutionAndAddSourceTerm<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z),
                t[patchIndex],
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#endif
      } else {
#if Dimensions == 2
#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
              loopbodies::copySolution(mappedPointersToQIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y), unknown, mappedPointersToQOut[patchIndex], QOutEnumerator);
            }
          }
        }
#else
#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
                loopbodies::copySolution(
                  mappedPointersToQIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y, z), unknown, mappedPointersToQOut[patchIndex], QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      // ====================================================
      // Compute damping due to max eigenvalue
      // ====================================================
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
          loopbodies::computeMaxEigenvalue<SolverType>(
            mappedPointersToQIn[patchIndex],
            QInEnumerator,
            rawPointerToCellCentre[patchIndex],
            rawPointerToCellSize[patchIndex],
            patchIndex,
            volumeIndex(x - HaloSize, y),
            t[patchIndex],
            dt[patchIndex],
            0,
            tempEigenvalueX,
            eigenvalueEnumerator
          );
        }
      }

#pragma omp parallel for simd collapse(2)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
          loopbodies::computeMaxEigenvalue<SolverType>(
            mappedPointersToQIn[patchIndex],
            QInEnumerator,
            rawPointerToCellCentre[patchIndex],
            rawPointerToCellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y - HaloSize),
            t[patchIndex],
            dt[patchIndex],
            1,
            tempEigenvalueY,
            eigenvalueEnumerator
          );
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
          for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
            loopbodies::updateSolutionWithEigenvalueDamping(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              tempEigenvalueX,
              tempEigenvalueY,
              tempEigenvalueZ,
              eigenvalueEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y),
              unknown,
              dt[patchIndex],
              mappedPointersToQOut[patchIndex],
              QOutEnumerator
            );
          }
        }
      }
#else
#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y, z),
              t[patchIndex],
              dt[patchIndex],
              0,
              tempEigenvalueX,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize, z),
              t[patchIndex],
              dt[patchIndex],
              1,
              tempEigenvalueY,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y, z - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              2,
              tempEigenvalueZ,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(4)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithEigenvalueDamping(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                tempEigenvalueX,
                tempEigenvalueY,
                tempEigenvalueZ,
                eigenvalueEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
      }
#endif


      // ====================================================
      // Normal (conservative) flux
      // ====================================================
      if constexpr (EvaluateFlux) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
            loopbodies::computeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y),
              t[patchIndex],
              dt[patchIndex],
              0, // normal
              tempFluxX,
              fluxEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              1, // normal
              tempFluxY,
              fluxEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithFlux(
                tempFluxX,
                tempFluxY,
                tempFluxZ,
                fluxEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x - HaloSize, y, z),
                t[patchIndex],
                dt[patchIndex],
                0, // normal
                tempFluxX,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y - HaloSize, z),
                t[patchIndex],
                dt[patchIndex],
                1, // normal
                tempFluxY,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z - HaloSize),
                t[patchIndex],
                dt[patchIndex],
                2, // normal
                tempFluxZ,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
                loopbodies::updateSolutionWithFlux(
                  tempFluxX,
                  tempFluxY,
                  tempFluxZ,
                  fluxEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  unknown,
                  dt[patchIndex],
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      if constexpr (EvaluateNonconservativeProduct) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; x++) {
            loopbodies::computeNonconservativeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y),
              t[patchIndex],
              dt[patchIndex],
              0, // normal
              tempNonconservativeProductX,
              ncpEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeNonconservativeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              1, // normal
              tempNonconservativeProductY,
              ncpEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithNonconservativeFlux(
                tempNonconservativeProductX,
                tempNonconservativeProductY,
                tempNonconservativeProductZ,
                ncpEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x - HaloSize, y, z),
                t[patchIndex],
                dt[patchIndex],
                0, // normal
                tempNonconservativeProductX,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y - HaloSize, z),
                t[patchIndex],
                dt[patchIndex],
                1, // normal
                tempNonconservativeProductY,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z - HaloSize),
                t[patchIndex],
                dt[patchIndex],
                2, // normal
                tempNonconservativeProductZ,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
                loopbodies::updateSolutionWithNonconservativeFlux(
                  tempNonconservativeProductX,
                  tempNonconservativeProductY,
                  tempNonconservativeProductZ,
                  ncpEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  unknown,
                  dt[patchIndex],
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      if constexpr (EvaluateMaximumEigenvalueAfterTimeStep) {
        double newMaxEigenvalue = 0.0;
#if Dimensions == 2
#pragma omp parallel for simd collapse(2) reduction(max : newMaxEigenvalue)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            newMaxEigenvalue = std::max(
              newMaxEigenvalue,
              loopbodies::reduceMaxEigenvalue<SolverType>(
                mappedPointersToQOut[patchIndex],
                QOutEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                t[patchIndex],
                dt[patchIndex]
              )
            );
          }
        }
#else
#pragma omp parallel for simd collapse(3) reduction(max : newMaxEigenvalue)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              newMaxEigenvalue = std::max(
                newMaxEigenvalue,
                loopbodies::reduceMaxEigenvalue<SolverType>(
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  t[patchIndex],
                  dt[patchIndex]
                )
              );
            }
          }
        }
#endif
        maxEigenvalue[patchIndex] = newMaxEigenvalue;
      }
    }

}

template <
  class SolverType,
  int  NumberOfVolumesPerAxisInPatch,
  int  HaloSize,
  int  NumberOfUnknowns,
  int  NumberOfAuxiliaryVariables,
  bool EvaluateFlux,
  bool EvaluateNonconservativeProduct,
  bool EvaluateSource,
  bool EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType,
  int IterationsPerTransfer
>
void timeStepWithRusanovPatchwiseStatelessOneHugeBuffer(
    int targetDevice, 
    GPUCellDataPacked& gpuPatchData,
    double*       tempFluxX,
    double*       tempFluxY,
    double*       tempFluxZ,
    double*       tempNonconservativeProductX,
    double*       tempNonconservativeProductY,
    double*       tempNonconservativeProductZ,
    double*       tempEigenvalueX,
    double*       tempEigenvalueY,
    double*       tempEigenvalueZ
)
{
    const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const TempDataEnumeratorType                  fluxEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  ncpEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch + 1, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  eigenvalueEnumerator(gpuPatchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, 1, 0);

    const int numberOfCells = gpuPatchData.numberOfCells;
    const ::tarch::la::Vector<Dimensions, double>* rawPointerToCellCentre = gpuPatchData.cellCentre;
    const ::tarch::la::Vector<Dimensions, double>* rawPointerToCellSize = gpuPatchData.cellSize;
    // const double* rawPointerToCellCentre = gpuPatchData.cellCentre[0].data();
    // const double* rawPointerToCellSize = gpuPatchData.cellSize[0].data();
    const double* t = gpuPatchData.t;
    const double* dt = gpuPatchData.dt;
    double* maxEigenvalue = gpuPatchData.maxEigenvalue;
    const double* const* mappedPointersToQIn = gpuPatchData.QIn;
    double** mappedPointersToQOut = gpuPatchData.QOut;

#pragma omp target teams distribute device(targetDevice) firstprivate(QInEnumerator, QOutEnumerator, fluxEnumerator, ncpEnumerator, eigenvalueEnumerator) // nowait
    for (int patchIndex = 0; patchIndex < numberOfCells; patchIndex++) {
      // ====================================================
      // Copy solution over and evaluate source (if required)
      // ====================================================
      if constexpr (EvaluateSource) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::copySolutionAndAddSourceTerm<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y),
              t[patchIndex],
              dt[patchIndex],
              mappedPointersToQOut[patchIndex],
              QOutEnumerator
            );
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::copySolutionAndAddSourceTerm<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z),
                t[patchIndex],
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#endif
      } else {
#if Dimensions == 2
#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
              loopbodies::copySolution(mappedPointersToQIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y), unknown, mappedPointersToQOut[patchIndex], QOutEnumerator);
            }
          }
        }
#else
#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
                loopbodies::copySolution(
                  mappedPointersToQIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y, z), unknown, mappedPointersToQOut[patchIndex], QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      // ====================================================
      // Compute damping due to max eigenvalue
      // ====================================================
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
          loopbodies::computeMaxEigenvalue<SolverType>(
            mappedPointersToQIn[patchIndex],
            QInEnumerator,
            rawPointerToCellCentre[patchIndex],
            rawPointerToCellSize[patchIndex],
            patchIndex,
            volumeIndex(x - HaloSize, y),
            t[patchIndex],
            dt[patchIndex],
            0,
            tempEigenvalueX,
            eigenvalueEnumerator
          );
        }
      }

#pragma omp parallel for simd collapse(2)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
          loopbodies::computeMaxEigenvalue<SolverType>(
            mappedPointersToQIn[patchIndex],
            QInEnumerator,
            rawPointerToCellCentre[patchIndex],
            rawPointerToCellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y - HaloSize),
            t[patchIndex],
            dt[patchIndex],
            1,
            tempEigenvalueY,
            eigenvalueEnumerator
          );
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
          for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
            loopbodies::updateSolutionWithEigenvalueDamping(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              tempEigenvalueX,
              tempEigenvalueY,
              tempEigenvalueZ,
              eigenvalueEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y),
              unknown,
              dt[patchIndex],
              mappedPointersToQOut[patchIndex],
              QOutEnumerator
            );
          }
        }
      }
#else
#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y, z),
              t[patchIndex],
              dt[patchIndex],
              0,
              tempEigenvalueX,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize, z),
              t[patchIndex],
              dt[patchIndex],
              1,
              tempEigenvalueY,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(3)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeMaxEigenvalue<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y, z - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              2,
              tempEigenvalueZ,
              eigenvalueEnumerator
            );
          }
        }
      }

#pragma omp parallel for simd collapse(4)
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithEigenvalueDamping(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                tempEigenvalueX,
                tempEigenvalueY,
                tempEigenvalueZ,
                eigenvalueEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
      }
#endif


      // ====================================================
      // Normal (conservative) flux
      // ====================================================
      if constexpr (EvaluateFlux) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
            loopbodies::computeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y),
              t[patchIndex],
              dt[patchIndex],
              0, // normal
              tempFluxX,
              fluxEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              1, // normal
              tempFluxY,
              fluxEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithFlux(
                tempFluxX,
                tempFluxY,
                tempFluxZ,
                fluxEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x - HaloSize, y, z),
                t[patchIndex],
                dt[patchIndex],
                0, // normal
                tempFluxX,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y - HaloSize, z),
                t[patchIndex],
                dt[patchIndex],
                1, // normal
                tempFluxY,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z - HaloSize),
                t[patchIndex],
                dt[patchIndex],
                2, // normal
                tempFluxZ,
                fluxEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
                loopbodies::updateSolutionWithFlux(
                  tempFluxX,
                  tempFluxY,
                  tempFluxZ,
                  fluxEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  unknown,
                  dt[patchIndex],
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      if constexpr (EvaluateNonconservativeProduct) {
#if Dimensions == 2
#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; x++) {
            loopbodies::computeNonconservativeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x - HaloSize, y),
              t[patchIndex],
              dt[patchIndex],
              0, // normal
              tempNonconservativeProductX,
              ncpEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(2)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            loopbodies::computeNonconservativeFlux<SolverType>(
              mappedPointersToQIn[patchIndex],
              QInEnumerator,
              rawPointerToCellCentre[patchIndex],
              rawPointerToCellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y - HaloSize),
              t[patchIndex],
              dt[patchIndex],
              1, // normal
              tempNonconservativeProductY,
              ncpEnumerator
            );
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
              loopbodies::updateSolutionWithNonconservativeFlux(
                tempNonconservativeProductX,
                tempNonconservativeProductY,
                tempNonconservativeProductZ,
                ncpEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                unknown,
                dt[patchIndex],
                mappedPointersToQOut[patchIndex],
                QOutEnumerator
              );
            }
          }
        }
#else
#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x - HaloSize, y, z),
                t[patchIndex],
                dt[patchIndex],
                0, // normal
                tempNonconservativeProductX,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y - HaloSize, z),
                t[patchIndex],
                dt[patchIndex],
                1, // normal
                tempNonconservativeProductY,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(3)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch + 2 * HaloSize - 1; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              loopbodies::computeNonconservativeFlux<SolverType>(
                mappedPointersToQIn[patchIndex],
                QInEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y, z - HaloSize),
                t[patchIndex],
                dt[patchIndex],
                2, // normal
                tempNonconservativeProductZ,
                ncpEnumerator
              );
            }
          }
        }

#pragma omp parallel for simd collapse(4)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              for (int unknown = 0; unknown < NumberOfUnknowns; unknown++) {
                loopbodies::updateSolutionWithNonconservativeFlux(
                  tempNonconservativeProductX,
                  tempNonconservativeProductY,
                  tempNonconservativeProductZ,
                  ncpEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  unknown,
                  dt[patchIndex],
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator
                );
              }
            }
          }
        }
#endif
      }

      if constexpr (EvaluateMaximumEigenvalueAfterTimeStep) {
        double newMaxEigenvalue = 0.0;
#if Dimensions == 2
#pragma omp parallel for simd collapse(2) reduction(max : newMaxEigenvalue)
        for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
          for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
            newMaxEigenvalue = std::max(
              newMaxEigenvalue,
              loopbodies::reduceMaxEigenvalue<SolverType>(
                mappedPointersToQOut[patchIndex],
                QOutEnumerator,
                rawPointerToCellCentre[patchIndex],
                rawPointerToCellSize[patchIndex],
                patchIndex,
                volumeIndex(x, y),
                t[patchIndex],
                dt[patchIndex]
              )
            );
          }
        }
#else
#pragma omp parallel for simd collapse(3) reduction(max : newMaxEigenvalue)
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          for (int y = 0; y < NumberOfVolumesPerAxisInPatch; y++) {
            for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++) {
              newMaxEigenvalue = std::max(
                newMaxEigenvalue,
                loopbodies::reduceMaxEigenvalue<SolverType>(
                  mappedPointersToQOut[patchIndex],
                  QOutEnumerator,
                  rawPointerToCellCentre[patchIndex],
                  rawPointerToCellSize[patchIndex],
                  patchIndex,
                  volumeIndex(x, y, z),
                  t[patchIndex],
                  dt[patchIndex]
                )
              );
            }
          }
        }
#endif
        maxEigenvalue[patchIndex] = newMaxEigenvalue;
      }
    }
}



}; // namespace exahype2::fv::rusanov::omp::internal

template <
  class SolverType,
  int  NumberOfVolumesPerAxisInPatch,
  int  HaloSize,
  int  NumberOfUnknowns,
  int  NumberOfAuxiliaryVariables,
  bool EvaluateFlux,
  bool EvaluateNonconservativeProduct,
  bool EvaluateSource,
  bool EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType,
  int IterationsPerTransfer
>
void exahype2::fv::rusanov::omp::timeStepWithRusanovPatchwiseHeapStatelessOneHugeBuffer(int targetDevice, CellData& patchData) 
{
    const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const TempDataEnumeratorType                  fluxEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  ncpEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch + 1, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  eigenvalueEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, 1, 0);

    GPUCellData gpuPatchData(patchData, QInEnumerator, QOutEnumerator, targetDevice);

    double* tempFluxX                   = nullptr;
    double* tempFluxY                   = nullptr;
    double* tempFluxZ                   = nullptr;
    double* tempNonconservativeProductX = nullptr;
    double* tempNonconservativeProductY = nullptr;
    double* tempNonconservativeProductZ = nullptr;
    double* tempEigenvalueX             = nullptr;
    double* tempEigenvalueY             = nullptr;
    double* tempEigenvalueZ             = nullptr;
    if constexpr (EvaluateFlux) {
        tempFluxX                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        tempFluxY                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        if constexpr (Dimensions == 3) {
            tempFluxZ                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        }
    }
    if constexpr (EvaluateNonconservativeProduct) {
        tempNonconservativeProductX = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        tempNonconservativeProductY = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        if constexpr (Dimensions == 3) {
            tempNonconservativeProductZ = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        }
    }
    tempEigenvalueX             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);
    tempEigenvalueY             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);
    tempEigenvalueZ             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);


    for (int i = 0; i < IterationsPerTransfer; ++i) {
        internal::timeStepWithRusanovPatchwiseStatelessOneHugeBuffer<
            SolverType,
            NumberOfVolumesPerAxisInPatch,
            HaloSize,
            NumberOfUnknowns,
            NumberOfAuxiliaryVariables,
            EvaluateFlux,
            EvaluateNonconservativeProduct,
            EvaluateSource,
            EvaluateMaximumEigenvalueAfterTimeStep,
            TempDataEnumeratorType,
            IterationsPerTransfer
            >(
            targetDevice, 
            gpuPatchData,
            tempFluxX,
            tempFluxY,
            tempFluxZ,
            tempNonconservativeProductX,
            tempNonconservativeProductY,
            tempNonconservativeProductZ,
            tempEigenvalueX,
            tempEigenvalueY,
            tempEigenvalueZ
        );
    }

    omp_target_free(tempFluxX, targetDevice);
    omp_target_free(tempFluxY, targetDevice);
    omp_target_free(tempFluxZ, targetDevice);
    omp_target_free(tempNonconservativeProductX, targetDevice);
    omp_target_free(tempNonconservativeProductY, targetDevice);
    omp_target_free(tempNonconservativeProductZ, targetDevice);
    omp_target_free(tempEigenvalueX, targetDevice);
    omp_target_free(tempEigenvalueY, targetDevice);
    omp_target_free(tempEigenvalueZ, targetDevice);

    gpuPatchData.copyToHost(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep);
}

template <
  class SolverType,
  int  NumberOfVolumesPerAxisInPatch,
  int  HaloSize,
  int  NumberOfUnknowns,
  int  NumberOfAuxiliaryVariables,
  bool EvaluateFlux,
  bool EvaluateNonconservativeProduct,
  bool EvaluateSource,
  bool EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType,
  int IterationsPerTransfer
>
void exahype2::fv::rusanov::omp::timeStepWithRusanovPatchwiseHeapStatelessOneHugeBufferPacked(int targetDevice, CellData& patchData) 
{
    const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
    const TempDataEnumeratorType                  fluxEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  ncpEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch + 1, HaloSize, NumberOfUnknowns, 0);
    const TempDataEnumeratorType                  eigenvalueEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, 1, 0);

    GPUCellDataPacked gpuPatchData(patchData, QInEnumerator, QOutEnumerator, targetDevice);

    double* tempFluxX                   = nullptr;
    double* tempFluxY                   = nullptr;
    double* tempFluxZ                   = nullptr;
    double* tempNonconservativeProductX = nullptr;
    double* tempNonconservativeProductY = nullptr;
    double* tempNonconservativeProductZ = nullptr;
    double* tempEigenvalueX             = nullptr;
    double* tempEigenvalueY             = nullptr;
    double* tempEigenvalueZ             = nullptr;
    if constexpr (EvaluateFlux) {
        tempFluxX                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        tempFluxY                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        if constexpr (Dimensions == 3) {
            tempFluxZ                   = (double*)omp_target_alloc(fluxEnumerator.size() * sizeof(double), targetDevice);
        }
    }
    if constexpr (EvaluateNonconservativeProduct) {
        tempNonconservativeProductX = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        tempNonconservativeProductY = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        if constexpr (Dimensions == 3) {
            tempNonconservativeProductZ = (double*)omp_target_alloc(ncpEnumerator.size() * sizeof(double), targetDevice);
        }
    }
    tempEigenvalueX             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);
    tempEigenvalueY             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);
    tempEigenvalueZ             = (double*)omp_target_alloc(eigenvalueEnumerator.size() * sizeof(double), targetDevice);


    for (int i = 0; i < IterationsPerTransfer; ++i) {
        internal::timeStepWithRusanovPatchwiseStatelessOneHugeBuffer<
            SolverType,
            NumberOfVolumesPerAxisInPatch,
            HaloSize,
            NumberOfUnknowns,
            NumberOfAuxiliaryVariables,
            EvaluateFlux,
            EvaluateNonconservativeProduct,
            EvaluateSource,
            EvaluateMaximumEigenvalueAfterTimeStep,
            TempDataEnumeratorType,
            IterationsPerTransfer
            >(
            targetDevice, 
            gpuPatchData,
            tempFluxX,
            tempFluxY,
            tempFluxZ,
            tempNonconservativeProductX,
            tempNonconservativeProductY,
            tempNonconservativeProductZ,
            tempEigenvalueX,
            tempEigenvalueY,
            tempEigenvalueZ
        );
    }

    omp_target_free(tempFluxX, targetDevice);
    omp_target_free(tempFluxY, targetDevice);
    omp_target_free(tempFluxZ, targetDevice);
    omp_target_free(tempNonconservativeProductX, targetDevice);
    omp_target_free(tempNonconservativeProductY, targetDevice);
    omp_target_free(tempNonconservativeProductZ, targetDevice);
    omp_target_free(tempEigenvalueX, targetDevice);
    omp_target_free(tempEigenvalueY, targetDevice);
    omp_target_free(tempEigenvalueZ, targetDevice);

    gpuPatchData.copyToHost(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep);
}
