// This file is part of the ExaHyPE2 project. For conditions of distribution and
// use, please see the copyright notice at www.peano-framework.org

template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless(int targetDevice, auto& patchData) {
  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const TempDataEnumeratorType                  fluxEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, 0);
  const TempDataEnumeratorType                  ncpEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch + 1, HaloSize, NumberOfUnknowns, 0);
  const TempDataEnumeratorType                  eigenvalueEnumerator(patchData.numberOfCells, NumberOfVolumesPerAxisInPatch, HaloSize, 1, 0);

  double* tempFluxX                   = EvaluateFlux ? ::sycl::malloc_device<double>(fluxEnumerator.size(), queue) : nullptr;
  double* tempFluxY                   = EvaluateFlux ? ::sycl::malloc_device<double>(fluxEnumerator.size(), queue) : nullptr;
  double* tempFluxZ                   = EvaluateFlux and Dimensions == 3 ? ::sycl::malloc_device<double>(fluxEnumerator.size(), queue) : nullptr;
  double* tempNonconservativeProductX = EvaluateNonconservativeProduct ? ::sycl::malloc_device<double>(ncpEnumerator.size(), queue) : nullptr;
  double* tempNonconservativeProductY = EvaluateNonconservativeProduct ? ::sycl::malloc_device<double>(ncpEnumerator.size(), queue) : nullptr;
  double* tempNonconservativeProductZ = EvaluateNonconservativeProduct and Dimensions == 3 ? ::sycl::malloc_device<double>(ncpEnumerator.size(), queue) : nullptr;
  double* tempEigenvalueX             = ::sycl::malloc_device<double>(eigenvalueEnumerator.size(), queue);
  double* tempEigenvalueY             = ::sycl::malloc_device<double>(eigenvalueEnumerator.size(), queue);
  double* tempEigenvalueZ             = ::sycl::malloc_device<double>(eigenvalueEnumerator.size(), queue);

  const std::size_t numberOfPatches = patchData.numberOfCells;

  ::sycl::event copySolutionEvent;
  // ====================================================
  // Copy solution over and evaluate source (if required)
  // ====================================================
  if constexpr (EvaluateSource) {
#if Dimensions == 2
    copySolutionEvent = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        loopbodies::copySolutionAndAddSourceTerm<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          patchData.QOut[patchIndex],
          QOutEnumerator
        );
      });
    });
#else
    copySolutionEvent = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++) {
          loopbodies::copySolutionAndAddSourceTerm<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            patchData.QOut[patchIndex],
            QOutEnumerator
          );
        }
      });
    });
#endif
  } else {
#if Dimensions == 2
    copySolutionEvent = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
          loopbodies::copySolution(patchData.QIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y), unknown, patchData.QOut[patchIndex], QOutEnumerator);
        }
      });
    });
#else
    copySolutionEvent = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++)
          for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
            loopbodies::copySolution(patchData.QIn[patchIndex], QInEnumerator, patchIndex, volumeIndex(x, y, z), unknown, patchData.QOut[patchIndex], QOutEnumerator);
          }
      });
    });
#endif
  }

  // ====================================================
  // Compute damping due to max eigenvalue
  // ====================================================
  ::sycl::event updateWithEigenvalue;
#if Dimensions == 2
  ::sycl::event computeMaxEigenvalueX = queue.submit([&](::sycl::handler& handle) {
    handle.depends_on(copySolutionEvent);
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch + 2 * HaloSize}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int y          = i[1];
      int x          = i[2] - HaloSize;
      loopbodies::computeMaxEigenvalue<SolverType>(
        patchData.QIn[patchIndex],
        QInEnumerator,
        patchData.cellCentre[patchIndex],
        patchData.cellSize[patchIndex],
        patchIndex,
        volumeIndex(x, y),
        patchData.t[patchIndex],
        patchData.dt[patchIndex],
        0,
        tempEigenvalueX,
        eigenvalueEnumerator
      );
    });
  });
  ::sycl::event computeMaxEigenvalueY = queue.submit([&](::sycl::handler& handle) {
    handle.depends_on(computeMaxEigenvalueX);
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch + 2 * HaloSize, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int y          = i[1] - HaloSize;
      int x          = i[2];
      loopbodies::computeMaxEigenvalue<SolverType>(
        patchData.QIn[patchIndex],
        QInEnumerator,
        patchData.cellCentre[patchIndex],
        patchData.cellSize[patchIndex],
        patchIndex,
        volumeIndex(x, y),
        patchData.t[patchIndex],
        patchData.dt[patchIndex],
        1,
        tempEigenvalueY,
        eigenvalueEnumerator
      );
    });
  });

  updateWithEigenvalue = queue.submit([&](::sycl::handler& handle) {
    handle.depends_on(copySolutionEvent);
    handle.depends_on(computeMaxEigenvalueX);
    handle.depends_on(computeMaxEigenvalueY);
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int y          = i[1];
      int x          = i[2];
      for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
        loopbodies::updateSolutionWithEigenvalueDamping(
          patchData.QIn[patchIndex],
          QInEnumerator,
          tempEigenvalueX,
          tempEigenvalueY,
          tempEigenvalueZ,
          eigenvalueEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y),
          unknown,
          patchData.dt[patchIndex],
          patchData.QOut[patchIndex],
          QOutEnumerator
        );
      }
    });
  });
#else
  ::sycl::event computeMaxEigenvalueX = queue.submit([&](::sycl::handler& handle) {
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int z          = i[1];
      int y          = i[2];
      for (int x = -HaloSize; x < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); x++) {
        loopbodies::computeMaxEigenvalue<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y, z),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          0,
          tempEigenvalueX,
          eigenvalueEnumerator
        );
      }
    });
  });
  ::sycl::event computeMaxEigenvalueY = queue.submit([&](::sycl::handler& handle) {
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int x          = i[1];
      int z          = i[2];
      for (int y = -HaloSize; y < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); y++) {
        loopbodies::computeMaxEigenvalue<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y, z),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          1,
          tempEigenvalueY,
          eigenvalueEnumerator
        );
      }
    });
  });
  ::sycl::event computeMaxEigenvalueZ = queue.submit([&](::sycl::handler& handle) {
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int x          = i[1];
      int y          = i[2];
      for (int z = -HaloSize; z < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); z++) {
        loopbodies::computeMaxEigenvalue<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y, z),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          2,
          tempEigenvalueZ,
          eigenvalueEnumerator
        );
      }
    });
  });

  updateWithEigenvalue = queue.submit([&](::sycl::handler& handle) {
    handle.depends_on(copySolutionEvent);
    handle.depends_on(computeMaxEigenvalueX);
    handle.depends_on(computeMaxEigenvalueY);
    handle.depends_on(computeMaxEigenvalueZ);
    handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
      int patchIndex = i[0];
      int x          = i[1];
      int y          = i[2];
      for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++)
        for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
          loopbodies::updateSolutionWithEigenvalueDamping(
            patchData.QIn[patchIndex],
            QInEnumerator,
            tempEigenvalueX,
            tempEigenvalueY,
            tempEigenvalueZ,
            eigenvalueEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            unknown,
            patchData.dt[patchIndex],
            patchData.QOut[patchIndex],
            QOutEnumerator
          );
        }
    });
  });
#endif

  // ====================================================
  // Normal (conservative) flux
  // ====================================================
  ::sycl::event updateWithFlux;
  if constexpr (EvaluateFlux) {
#if Dimensions == 2
    ::sycl::event computeFluxX = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch + 2 * HaloSize}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int y          = i[1];
        int x          = i[2] - HaloSize;
        loopbodies::computeFlux<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          0, // normal
          tempFluxX,
          fluxEnumerator
        );
      });
    });
    ::sycl::event computeFluxY = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(computeFluxX);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch + 2 * HaloSize}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2] - HaloSize;
        loopbodies::computeFlux<SolverType>(
          patchData.QIn[patchIndex],
          QInEnumerator,
          patchData.cellCentre[patchIndex],
          patchData.cellSize[patchIndex],
          patchIndex,
          volumeIndex(x, y),
          patchData.t[patchIndex],
          patchData.dt[patchIndex],
          1, // normal
          tempFluxY,
          fluxEnumerator
        );
      });
    });

    updateWithFlux = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(computeFluxY);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
          loopbodies::updateSolutionWithFlux(
            tempFluxX,
            tempFluxY,
            tempFluxZ,
            fluxEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y),
            unknown,
            patchData.dt[patchIndex],
            patchData.QOut[patchIndex],
            QOutEnumerator
          );
        }
      });
    });
#else
    ::sycl::event computeFluxX = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int z          = i[1];
        int y          = i[2];
        for (int x = -HaloSize; x < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); x++) {
          loopbodies::computeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            0, // normal
            tempFluxX,
            fluxEnumerator
          );
        }
      });
    });
    ::sycl::event computeFluxY = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int z          = i[2];
        for (int y = -HaloSize; y < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); y++) {
          loopbodies::computeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            1, // normal
            tempFluxY,
            fluxEnumerator
          );
        }
      });
    });
    ::sycl::event computeFluxZ = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int z = -HaloSize; z < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize); z++) {
          loopbodies::computeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            2, // normal
            tempFluxZ,
            fluxEnumerator
          );
        }
      });
    });

    updateWithFlux            = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.depends_on(computeFluxX);
      handle.depends_on(computeFluxY);
      handle.depends_on(computeFluxZ);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int z          = i[1];
        int y          = i[2];
        for (int x = 0; x < NumberOfVolumesPerAxisInPatch; x++)
          for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
            loopbodies::updateSolutionWithFlux(
              tempFluxX,
              tempFluxY,
              tempFluxZ,
              fluxEnumerator,
              patchData.cellCentre[patchIndex],
              patchData.cellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y, z),
              unknown,
              patchData.dt[patchIndex],
              patchData.QOut[patchIndex],
              QOutEnumerator
            );
          }
      });
    });
#endif
  }

  ::sycl::event updateWithNCP;
  if constexpr (EvaluateNonconservativeProduct) {
#if Dimensions == 2
    ::sycl::event computeNCPX = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<2>{numberOfPatches, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<2> i) {
        int patchIndex = i[0];
        int y          = i[1];
        for (int x = -HaloSize; x < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize - 1); x++) {
          loopbodies::computeNonconservativeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            0, // normal
            tempNonconservativeProductX,
            ncpEnumerator
          );
        }
      });
    });
    ::sycl::event computeNCPY = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<2>{numberOfPatches, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<2> i) {
        int patchIndex = i[0];
        int x          = i[1];
        for (int y = -HaloSize; y < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize - 1); y++) {
          loopbodies::computeNonconservativeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            1, // normal
            tempNonconservativeProductY,
            ncpEnumerator
          );
        }
      });
    });

    updateWithNCP = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.depends_on(updateWithFlux);
      handle.depends_on(computeNCPX);
      handle.depends_on(computeNCPY);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
          loopbodies::updateSolutionWithNonconservativeFlux(
            tempNonconservativeProductX,
            tempNonconservativeProductY,
            tempNonconservativeProductZ,
            ncpEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y),
            unknown,
            patchData.dt[patchIndex],
            patchData.QOut[patchIndex],
            QOutEnumerator
          );
        }
      });
    });
#else
    ::sycl::event computeNCPX = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int z          = i[1];
        int y          = i[2];
        for (int x = -HaloSize; x < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize - 1); x++) {
          loopbodies::computeNonconservativeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            0, // normal
            tempNonconservativeProductX,
            ncpEnumerator
          );
        }
      });
    });
    ::sycl::event computeNCPY = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int z          = i[2];
        for (int y = -HaloSize; y < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize - 1); y++) {
          loopbodies::computeNonconservativeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            1, // normal
            tempNonconservativeProductY,
            ncpEnumerator
          );
        }
      });
    });
    ::sycl::event computeNCPZ = queue.submit([&](::sycl::handler& handle) {
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int z = -HaloSize; z < static_cast<int>(NumberOfVolumesPerAxisInPatch + HaloSize - 1); z++) {
          loopbodies::computeNonconservativeFlux<SolverType>(
            patchData.QIn[patchIndex],
            QInEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex],
            2, // normal
            tempNonconservativeProductZ,
            ncpEnumerator
          );
        }
      });
    });

    updateWithNCP                          = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.depends_on(updateWithFlux);
      handle.depends_on(computeNCPX);
      handle.depends_on(computeNCPY);
      handle.depends_on(computeNCPZ);
      handle.parallel_for(::sycl::range<3>{numberOfPatches, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch}, [=](::sycl::item<3> i) {
        int patchIndex = i[0];
        int x          = i[1];
        int y          = i[2];
        for (int z = 0; z < NumberOfVolumesPerAxisInPatch; z++)
          for (int unknown = 0; unknown < NumberOfUnknowns + NumberOfAuxiliaryVariables; unknown++) {
            loopbodies::updateSolutionWithNonconservativeFlux(
              tempNonconservativeProductX,
              tempNonconservativeProductY,
              tempNonconservativeProductZ,
              ncpEnumerator,
              patchData.cellCentre[patchIndex],
              patchData.cellSize[patchIndex],
              patchIndex,
              volumeIndex(x, y, z),
              unknown,
              patchData.dt[patchIndex],
              patchData.QOut[patchIndex],
              QOutEnumerator
            );
          }
      });
    });
#endif
  }

  ::sycl::event computeMaxEigenvalueAfterTimeStepEvent;
  if constexpr (EvaluateMaximumEigenvalueAfterTimeStep) {
#if Dimensions == 2
    computeMaxEigenvalueAfterTimeStepEvent = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.depends_on(updateWithFlux);
      handle.depends_on(updateWithNCP);
      ::sycl::range<2> totalWorkitem{NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch * numberOfPatches};
      ::sycl::range<2> workgroupSize{NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch};
      handle.parallel_for(::sycl::nd_range<2>{totalWorkitem, workgroupSize}, [=](::sycl::nd_item<2> i) {
        int patchIndex                      = i.get_group(1);
        int y                               = i.get_local_id(0);
        int x                               = i.get_local_id(1);
        patchData.maxEigenvalue[patchIndex] = ::sycl::reduce_over_group(
          i.get_group(),
          loopbodies::reduceMaxEigenvalue<SolverType>(
            patchData.QOut[patchIndex],
            QOutEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y),
            patchData.t[patchIndex],
            patchData.dt[patchIndex]
          ),
          ::sycl::maximum<>()
        );
      });
    });
#else
    computeMaxEigenvalueAfterTimeStepEvent = queue.submit([&](::sycl::handler& handle) {
      handle.depends_on(updateWithEigenvalue);
      handle.depends_on(updateWithFlux);
      handle.depends_on(updateWithNCP);
      ::sycl::range<3> totalWorkitem{NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch * numberOfPatches};
      ::sycl::range<3> workgroupSize{NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch, NumberOfVolumesPerAxisInPatch};
      handle.parallel_for(::sycl::nd_range<3>{totalWorkitem, workgroupSize}, [=](::sycl::nd_item<3> i) {
        int patchIndex                      = i.get_group(2);
        int z                               = i.get_local_id(0);
        int y                               = i.get_local_id(1);
        int x                               = i.get_local_id(2);
        patchData.maxEigenvalue[patchIndex] = ::sycl::reduce_over_group(
          i.get_group(),
          loopbodies::reduceMaxEigenvalue<SolverType>(
            patchData.QOut[patchIndex],
            QOutEnumerator,
            patchData.cellCentre[patchIndex],
            patchData.cellSize[patchIndex],
            patchIndex,
            volumeIndex(x, y, z),
            patchData.t[patchIndex],
            patchData.dt[patchIndex]
          ),
          ::sycl::maximum<>()
        );
      });
    });
#endif
  } else {
    updateWithEigenvalue.wait();
    updateWithFlux.wait();
    updateWithNCP.wait();
  }

  if (tempFluxX != nullptr) {
    ::sycl::free(tempFluxX, queue);
  }
  if (tempFluxY != nullptr) {
    ::sycl::free(tempFluxY, queue);
  }
  if (tempFluxZ != nullptr) {
    ::sycl::free(tempFluxZ, queue);
  }
  if (tempNonconservativeProductX != nullptr) {
    ::sycl::free(tempNonconservativeProductX, queue);
  }
  if (tempNonconservativeProductY != nullptr) {
    ::sycl::free(tempNonconservativeProductY, queue);
  }
  if (tempNonconservativeProductZ != nullptr) {
    ::sycl::free(tempNonconservativeProductZ, queue);
  }
  if (tempEigenvalueX != nullptr) {
    ::sycl::free(tempEigenvalueX, queue);
  }
  if (tempEigenvalueY != nullptr) {
    ::sycl::free(tempEigenvalueY, queue);
  }
  if (tempEigenvalueZ != nullptr) {
    ::sycl::free(tempEigenvalueZ, queue);
  }
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedUSMStateless(int targetDevice, CellData& patchData) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedUSMStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUUSMCellData                                gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedUSMStateless()");
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedHeapStateless(int targetDevice, CellData& patchData) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedHeapStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUCopyCellData                               gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedHeapStateless()");
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedManagedStateless(int targetDevice, CellData& patchData) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedManagedStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUManagedCellData                            gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedManagedStateless()");
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedUSMStateless(int targetDevice, CellData& patchData, ::tarch::timing::Measurement& measurement) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedUSMStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUUSMCellData                                gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  tarch::timing::Watch watch("exahype2::fv::rusanov::sycl", "timeStepWithRusanovBatchedUSMStateless", false, true);
  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);
  watch.stop();
  measurement.setValue(watch.getCalendarTime());

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedUSMStateless()");
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedHeapStateless(int targetDevice, CellData& patchData, ::tarch::timing::Measurement& measurement) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedHeapStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUCopyCellData                               gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  tarch::timing::Watch watch("exahype2::fv::rusanov::sycl", "timeStepWithRusanovBatchedHeapStateless", false, true);
  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);
  watch.stop();
  measurement.setValue(watch.getCalendarTime());

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedHeapStateless()");
}


template <
  class SolverType,
  std::size_t NumberOfVolumesPerAxisInPatch,
  std::size_t HaloSize,
  std::size_t NumberOfUnknowns,
  std::size_t NumberOfAuxiliaryVariables,
  bool        EvaluateFlux,
  bool        EvaluateNonconservativeProduct,
  bool        EvaluateSource,
  bool        EvaluateMaximumEigenvalueAfterTimeStep,
  class TempDataEnumeratorType>
void exahype2::fv::rusanov::sycl::timeStepWithRusanovBatchedManagedStateless(int targetDevice, CellData& patchData, ::tarch::timing::Measurement& measurement) {
  static_assert(HaloSize == 1);

  static tarch::logging::Log _log("exahype2::fv::rusanov::sycl");
  logTraceIn("timeStepWithRusanovBatchedManagedStateless()");

  ::sycl::queue& queue = tarch::accelerator::getSYCLQueue(targetDevice);

  const enumerator::AoSLexicographicEnumerator QInEnumerator(1, NumberOfVolumesPerAxisInPatch, HaloSize, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  const enumerator::AoSLexicographicEnumerator QOutEnumerator(1, NumberOfVolumesPerAxisInPatch, 0, NumberOfUnknowns, NumberOfAuxiliaryVariables);
  GPUManagedCellData                            gpuPatchData(patchData, QInEnumerator, QOutEnumerator, queue);

  tarch::timing::Watch watch("exahype2::fv::rusanov::sycl", "timeStepWithRusanovBatchedManagedStateless", false, true);
  exahype2::fv::rusanov::sycl::internal::timeStepWithRusanovBatchedStateless<
    SolverType,
    NumberOfVolumesPerAxisInPatch,
    HaloSize,
    NumberOfUnknowns,
    NumberOfAuxiliaryVariables,
    EvaluateFlux,
    EvaluateNonconservativeProduct,
    EvaluateSource,
    EvaluateMaximumEigenvalueAfterTimeStep,
    TempDataEnumeratorType>(targetDevice, gpuPatchData);
  watch.stop();
  measurement.setValue(watch.getCalendarTime());

  gpuPatchData.destroy(patchData, QOutEnumerator, EvaluateMaximumEigenvalueAfterTimeStep, queue);

  logTraceOut("timeStepWithRusanovBatchedManagedStateless()");
}
