//
// Solver file of Peano's PETSc add-on
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#pragma once


#include "tarch/la/Vector.h"
#include "tarch/la/Matrix.h"
#include "tarch/logging/Log.h"
#include "tarch/multicore/BooleanSemaphore.h"
#include "tarch/accelerator/accelerator.h"

#include "peano4/utils/Globals.h"

#include "petsc/LocalToGlobalMap.h"
#include "petsc/LinearEquationSystem.h"

#include "Constants.h"

#include "vertexdata/{{SOLVER_NAME}}PETScData.h"
#include "facedata/{{SOLVER_NAME}}PETScData.h"
#include "celldata/{{SOLVER_NAME}}PETScData.h"


{{SOLVER_INCLUDES}}


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



class {{NAMESPACE | join("::")}}::{{CLASSNAME}} {
  public:
    static constexpr double     MinH = {{MIN_H}};
    static constexpr double     MaxH = {{MAX_H}};

    static constexpr int        VertexUnknowns = {{VERTEX_CARDINALITY}};

    {{CLASSNAME}}();
    virtual ~{{CLASSNAME}}();

    /**
     * Initialise a vertex degree of freedom
     */
    virtual void initVertex(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h,
      tarch::la::Vector< {{VERTEX_CARDINALITY}}, double >&  value,
      tarch::la::Vector< {{VERTEX_CARDINALITY}}, double >&  rhs
    ) = 0;

    virtual vertexdata::{{SOLVER_NAME}}PETScData::Type getVertexDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    ) final;

    /*
    In this experiement, we have data only on vertices, so the following
    method returns Outside
    */
    virtual facedata::{{SOLVER_NAME}}PETScData::Type getFaceDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    );

    /*
    We need the cells to be marked Interior. Only cells marked interior
    are ones that we add elements to PETSc matrix.
    */
    virtual celldata::{{SOLVER_NAME}}PETScData::Type getCellDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    );

    /**
     * Called after assembly is complete.
     *
     * Usually means we can now actually compute the local-global mapping. Up
     * to this point, we normally know only the thread-local local-global
     * indices, which we still have to shift and combine with all the other
     * mappings around.
     */
    void finishAssembly();

    virtual tarch::la::Matrix< {{VERTEX_CARDINALITY}}*TwoPowerD, {{VERTEX_CARDINALITY}}*TwoPowerD, double > getLhsMatrix(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if CELL_LHS_MATRIX==[] %} = 0 {% endif %};


    virtual tarch::la::Matrix< {{VERTEX_CARDINALITY}}*TwoPowerD, {{VERTEX_CARDINALITY}}*TwoPowerD, double > getRhsMatrix(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if CELL_RHS_MATRIX==[] %} = 0 {% endif %};

    ::petsc::LocalToGlobalMap&      getLocalToGlobalMap();
    ::petsc::LinearEquationSystem&  getLinearEquationSystem();
  protected:
    static tarch::logging::Log  _log;

    double     _minH;
    double     _maxH;

    tarch::multicore::BooleanSemaphore  _semaphore;

    ::petsc::LocalToGlobalMap      _localToGlobalMap;
    ::petsc::LinearEquationSystem  _linearEquationSystem;
};



{# Empty line here #}
