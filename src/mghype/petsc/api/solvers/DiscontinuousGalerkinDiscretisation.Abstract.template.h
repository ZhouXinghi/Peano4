//
// Solver file of Peano's PETSc add-on
// Generated by Peano's Python API
// www.peano-framework.org
//
// This is generated. Don't change it! Every rerun of the Python API will
// overwrite your changes.
//
#pragma once


#include "tarch/la/Vector.h"
#include "tarch/la/Matrix.h"
#include "tarch/logging/Log.h"
#include "tarch/multicore/BooleanSemaphore.h"
#include "tarch/accelerator/accelerator.h"

#include "peano4/utils/Globals.h"

#include "petsc/LocalToGlobalMap.h"
#include "petsc/LinearEquationSystem.h"

#include "Constants.h"

#include "vertexdata/{{SOLVER_NAME}}PETScData.h"
#include "facedata/{{SOLVER_NAME}}PETScData.h"
#include "celldata/{{SOLVER_NAME}}PETScData.h"


{{SOLVER_INCLUDES}}


{% for item in NAMESPACE -%}
  namespace {{ item }} {

{%- endfor %}
  class {{CLASSNAME}};

{% for item in NAMESPACE -%}
  }
{%- endfor %}



class {{NAMESPACE | join("::")}}::{{CLASSNAME}} {
  public:
    static constexpr double     MinH = {{MIN_H}};
    static constexpr double     MaxH = {{MAX_H}};

    static const double         QuadraturePointsInUnitInterval[];

    static const double         GaussianIntegrationPoints[];
    static const double         GaussianIntegrationWeights[];

    static constexpr int        Order    = {{POLYNOMIAL_DEGREE}};
    static constexpr int        CellUnknowns = {{CELL_UNKNOWNS}};
    static constexpr int        FaceUnknowns = {{FACE_UNKNOWNS}};

    static constexpr int        FacesPerCell = 2 * Dimensions;

    #if Dimensions==2
    static constexpr int     NodesPerCell = (Order+1) * (Order+1);
    static constexpr int     NodesPerFace = (Order+1);
    #else
    static constexpr int     NodesPerCell = (Order+1) * (Order+1) * (Order+1);
    static constexpr int     NodesPerFace = (Order+1) * (Order+1);
    #endif

    static constexpr int     DoFsPerCell = CellUnknowns * NodesPerCell;

    {{CLASSNAME}}();
    virtual ~{{CLASSNAME}}();

    /**
     * Initialise a vertex degree of freedom
     */
    virtual void initNode(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  cellH,
      {% if CELL_UNKNOWNS==1 %}
      double&                                       value,
      double&                                       rhs,
      double&                                       exactSol
      {% else %}
      tarch::la::Vector< {{CELL_UNKNOWNS}}, double >&  value,
      tarch::la::Vector< {{CELL_UNKNOWNS}}, double >&  rhs
      tarch::la::Vector< {{CELL_UNKNOWNS}}, double >&  exactSol
      {% endif %}
    ) = 0;

    double EvalGaussianIntegral( double val );

    /**
     * In the DG case, there is no data tied to the vertices. Hence, this
     * routine returns Outside all the time.
     */
    virtual vertexdata::{{SOLVER_NAME}}PETScData::Type getVertexDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    ) final;


    /**
     * Find out what DoF type a face has
     *
     * The default implementation here sets the face type to boundary for the
     * boundaries of the computational domain, and to interior everywhere else.
     * You can alter this behaviour by overwriting this file. Admissible return
     * flags are
     *
     * - Interior
     * - Boundary
     * - Outside
     *
     * The result enum also offers Coarse. This however is not a valid result
     * here. Whenever this routine is called for faces on the global domain
     * boundary, you are not supposed to return Interior.
     */
    virtual facedata::{{SOLVER_NAME}}PETScData::Type getFaceDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    );


    /**
     * Find out what DoF type a cell has
     *
     * THe default implementation returns the interior flag. The enum also
     * offers a flag Coarse, but you are not supposed to return this one. If
     * you have a non-cubic domain, you can return Outside for a cell. In
     * this case, you have to amend the getFaceDoFType such that it returns
     * compatible boundary flags.
     */
    virtual celldata::{{SOLVER_NAME}}PETScData::Type getCellDoFType(
      const tarch::la::Vector<Dimensions, double>&  x,
      const tarch::la::Vector<Dimensions, double>&  h
    );


    /**
     * Called after assembly is complete.
     *
     * Usually means we can now actually compute the local-global mapping. Up
     * to this point, we normally know only the thread-local local-global
     * indices, which we still have to shift and combine with all the other
     * mappings around.
     */
    void finishAssembly();


    virtual tarch::la::Matrix< DoFsPerCell, DoFsPerCell, double > getLhsMatrix(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if CELL_CELL_LHS_MATRIX==[] %} = 0 {% endif %};


    virtual tarch::la::Matrix< DoFsPerCell, DoFsPerCell, double > getRhsMatrix(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if CELL_CELL_RHS_MATRIX==[] %} = 0 {% endif %};


    virtual tarch::la::Matrix< NodesPerFace*FaceUnknowns*FacesPerCell, DoFsPerCell, double > getProjectionOfCellDataOntoFace(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if CELL_TO_FACE_MATRIX==[] %} = 0 {% endif %};


    virtual tarch::la::Matrix< DoFsPerCell, NodesPerFace*FaceUnknowns*FacesPerCell, double > getProjectionOfRiemannSolutionOntoCell(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if FACE_TO_CELL_MATRIX==[] %} = 0 {% endif %};


    virtual tarch::la::Matrix< NodesPerFace*FaceUnknowns, 2*NodesPerFace*FaceUnknowns, double > getRiemannSolver(
      const tarch::la::Vector<Dimensions, double>&  cellCentre,
      const tarch::la::Vector<Dimensions, double>&  cellSize
    )
    {% if FACE_FACE_RIEMANN_PROBLEM_MATRIX==[] %} = 0 {% endif %};


    ::petsc::LocalToGlobalMap&      getLocalToGlobalMap();
    ::petsc::LinearEquationSystem&  getLinearEquationSystem();
  protected:
    static tarch::logging::Log  _log;

    double     _minH;
    double     _maxH;

    tarch::multicore::BooleanSemaphore  _semaphore;

    ::petsc::LocalToGlobalMap      _localToGlobalMap;
    ::petsc::LinearEquationSystem  _linearEquationSystem;

};



{# Empty line here #}
