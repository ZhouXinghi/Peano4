// **********************************************************************************************
// ***                                     !!!WARNING!!!                                      ***
// *** WARNING: AUTO GENERATED FILE! DO NOT MODIFY BY HAND! YOUR CHANGES WILL BE OVERWRITTEN! ***
// ***                                     !!!WARNING!!!                                      ***
// ***                  Generated by Peano's Python API: www.peano-framework.org              ***
// **********************************************************************************************
#include "AbstractAdvection.h"
#include "Constants.h"

#if defined(UseSmartMPI)
#include "tasks/AdvectionEnclaveTask.h"
#include "tarch/multicore/smartScheduling.h"
#endif

#include "tarch/NonCriticalAssertions.h"
#include "tarch/multicore/multicore.h"
#include "tarch/multicore/Lock.h"

#include <algorithm>

tarch::logging::Log   tutorials::exahype2::advection::AbstractAdvection::AbstractAdvection::_log( "tutorials::exahype2::advection::AbstractAdvection::AbstractAdvection" );

std::bitset<Dimensions> tutorials::exahype2::advection::AbstractAdvection::AbstractAdvection::PeriodicBC = tutorials::exahype2::advection::PeriodicBC;

tutorials::exahype2::advection::AbstractAdvection::AbstractAdvection():
  _solverState(SolverState::GridConstruction),
  _minTimeStamp(0.0),
  _maxTimeStamp(0.0),
  _minTimeStampThisTimeStep(0.0),
  _maxTimeStampThisTimeStep(0.0),
  // This way, we still compute the patch size without an overflow
  _minVolumeH(std::numeric_limits<double>::max()/NumberOfFiniteVolumesPerAxisPerPatch/2.0),
  _maxVolumeH(0.0),
  _minVolumeHThisTimeStep(std::numeric_limits<double>::max()/NumberOfFiniteVolumesPerAxisPerPatch/2.0),
  _maxVolumeHThisTimeStep(0.0),
  _minTimeStepSize(std::numeric_limits<double>::max()),
  _maxTimeStepSize(0.0),
  _minTimeStepSizeThisTimeStep(std::numeric_limits<double>::max()),
  _maxTimeStepSizeThisTimeStep(0.0),
  _patchUpdates(0) {
  _admissibleTimeStepSize = 0.0;
}

double tutorials::exahype2::advection::AbstractAdvection::getMaxMeshSize() const {
  return getMaxPatchSize();
}

double tutorials::exahype2::advection::AbstractAdvection::getMinMeshSize() const {
  return getMinPatchSize();
}


void tutorials::exahype2::advection::AbstractAdvection::suspendSolversForOneGridSweep() {
  _solverState = SolverState::Suspended;
}


double tutorials::exahype2::advection::AbstractAdvection::getMinPatchSize(bool ofCurrentlyRunningGridSweep) const {
  return getMinVolumeSize(ofCurrentlyRunningGridSweep) * NumberOfFiniteVolumesPerAxisPerPatch;
}

double tutorials::exahype2::advection::AbstractAdvection::getMaxPatchSize(bool ofCurrentlyRunningGridSweep) const {
  return getMaxVolumeSize(ofCurrentlyRunningGridSweep) * NumberOfFiniteVolumesPerAxisPerPatch;
}

double tutorials::exahype2::advection::AbstractAdvection::getMinVolumeSize(bool ofCurrentlyRunningGridSweep) const {
  return ofCurrentlyRunningGridSweep ? _minVolumeHThisTimeStep : _minVolumeH;
}

double tutorials::exahype2::advection::AbstractAdvection::getMaxVolumeSize(bool ofCurrentlyRunningGridSweep) const {
  return ofCurrentlyRunningGridSweep ? _maxVolumeHThisTimeStep : _maxVolumeH;
}

double tutorials::exahype2::advection::AbstractAdvection::getMinTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return ofCurrentlyRunningGridSweep ? _minTimeStampThisTimeStep : _minTimeStamp;
}

double tutorials::exahype2::advection::AbstractAdvection::getMaxTimeStamp(bool ofCurrentlyRunningGridSweep) const {
  return ofCurrentlyRunningGridSweep ? _maxTimeStampThisTimeStep : _maxTimeStamp;
}

double tutorials::exahype2::advection::AbstractAdvection::getMinTimeStepSize() const {
  return _minTimeStepSize;
}

double tutorials::exahype2::advection::AbstractAdvection::getMaxTimeStepSize() const {
  return _maxTimeStepSize;
}

void tutorials::exahype2::advection::AbstractAdvection::update(double timeStepSize, double timeStamp, double patchSize) {
  tarch::multicore::Lock lock(_semaphore);

  if ( tarch::la::greater(timeStepSize,0.0) ) {
    assertion1(timeStepSize<std::numeric_limits<double>::max()/10.0,timeStepSize);
    assertion1(timeStepSize>=0.0,timeStepSize);
    _minTimeStepSizeThisTimeStep = std::min(timeStepSize,_minTimeStepSizeThisTimeStep);
    _maxTimeStepSizeThisTimeStep = std::max(timeStepSize,_maxTimeStepSizeThisTimeStep);
    assertion2(_minTimeStepSizeThisTimeStep<=_maxTimeStepSizeThisTimeStep, _minTimeStepSizeThisTimeStep, _maxTimeStepSizeThisTimeStep );

    _patchUpdates++;

    _localMinTimeStampThisTimeStep = std::min(_localMinTimeStampThisTimeStep, timeStamp);
    _localMaxTimeStampThisTimeStep = std::max(_localMaxTimeStampThisTimeStep, timeStamp);
  }

  assertion1(timeStamp<std::numeric_limits<double>::max()/10.0,timeStamp);
  assertion1(timeStamp>=0.0,timeStamp);
  _maxTimeStampThisTimeStep = std::max(_maxTimeStampThisTimeStep,timeStamp);
  _minTimeStampThisTimeStep = std::min(_minTimeStampThisTimeStep,timeStamp);
  assertion2(_minTimeStampThisTimeStep<=_maxTimeStampThisTimeStep, _minTimeStampThisTimeStep, _maxTimeStampThisTimeStep );

  assertion1(patchSize<std::numeric_limits<double>::max()/NumberOfFiniteVolumesPerAxisPerPatch,patchSize);
  assertion1(patchSize>0.0,patchSize);
  _maxVolumeHThisTimeStep = std::max(_maxVolumeHThisTimeStep,patchSize / NumberOfFiniteVolumesPerAxisPerPatch);
  _minVolumeHThisTimeStep = std::min(_minVolumeHThisTimeStep,patchSize / NumberOfFiniteVolumesPerAxisPerPatch);
}

tutorials::exahype2::advection::AbstractAdvection::SolverState tutorials::exahype2::advection::AbstractAdvection::getSolverState() const {
  return _solverState;
}


::exahype2::RefinementCommand tutorials::exahype2::advection::AbstractAdvection::refinementCriterion(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t
) {
  
  ::exahype2::RefinementCommand result = ::exahype2::RefinementCommand::Keep;

  return result;
  
}



void tutorials::exahype2::advection::AbstractAdvection::initialCondition(
  [[maybe_unused]] double* __restrict__                         Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] bool                                         gridIsConstructed
) {
  [[maybe_unused]] const double v_0 = Q[0];
nonCriticalAssertion(Q[0] == Q[0]);
assertion(!std::isnan(v_0));
[[maybe_unused]] const double v_1 = Q[1];
nonCriticalAssertion(Q[1] == Q[1]);
assertion(!std::isnan(v_1));
const double x_0 = volumeCentre(0);
const double x_1 = volumeCentre(1);
const double h_0 = volumeH(0);
const double h_1 = volumeH(1);
Q[0] = x_0;
assertion(!std::isnan(Q[0]));
Q[1] = x_1;
assertion(!std::isnan(Q[1]));

}



void tutorials::exahype2::advection::AbstractAdvection::boundaryConditions(
  [[maybe_unused]] const double* __restrict__                   Qinside, // Qinside[2+0]
  [[maybe_unused]] double* __restrict__                         Qoutside, // Qoutside[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] int                                          normal
) {
  
  assertion(normal >= 0);
//assertion(normal < Dimensions);
assertion(!std::isnan(Qoutside[0]));
assertion(!std::isnan(Qinside[0]));
nonCriticalAssertion(Qinside[0] == Qinside[0]);
Qoutside[0] = Qinside[0];
nonCriticalAssertion(Qoutside[0] == Qoutside[0]);
assertion(!std::isnan(Qoutside[1]));
assertion(!std::isnan(Qinside[1]));
nonCriticalAssertion(Qinside[1] == Qinside[1]);
Qoutside[1] = Qinside[1];
nonCriticalAssertion(Qoutside[1] == Qoutside[1]);

  
}


void tutorials::exahype2::advection::AbstractAdvection::startGridConstructionStep() {
  assertion( _solverState == SolverState::GridConstruction );
}

void tutorials::exahype2::advection::AbstractAdvection::finishGridConstructionStep() {}

void tutorials::exahype2::advection::AbstractAdvection::startGridInitialisationStep() {
  assertion( _solverState == SolverState::GridConstruction );
  _solverState = SolverState::GridInitialisation;
  logDebug( "startGridInitialisationStep(...)", "new state is " << toString(_solverState) );
}

void tutorials::exahype2::advection::AbstractAdvection::finishGridInitialisationStep() {}

void tutorials::exahype2::advection::AbstractAdvection::startTimeStep(
  [[maybe_unused]] double globalMinTimeStamp,
  [[maybe_unused]] double globalMaxTimeStamp,
  [[maybe_unused]] double globalMinTimeStepSize,
  [[maybe_unused]] double globalMaxTimeStepSize
) {
  logDebug("startTimeStep(...)", "old state is " << toString(_solverState));

  if (
    _solverState == SolverState::GridInitialisation
  ) {
    _solverState = SolverState::PrimaryAfterGridInitialisation;
  } else if (
    _solverState == SolverState::Primary
    or
    _solverState == SolverState::PrimaryAfterGridInitialisation
  ) {
    _solverState = SolverState::Secondary;
  } else { // Plot initial condition, e.g.
    _solverState = SolverState::Primary;
  }

  
  if (
    tarch::mpi::Rank::getInstance().isGlobalMaster()
    and
    (_maxVolumeH>0.0 or _maxVolumeHThisTimeStep>0.0)
    and
    isFirstGridSweepOfTimeStep()
  ) {
    logInfo( "startTimeStep()", "Solver Advection:" );
    logInfo( "startTimeStep()", "t            = " << _minTimeStampThisTimeStep );
    logInfo( "startTimeStep()", "dt           = " << getAdmissibleTimeStepSize() );
    logInfo( "startTimeStep()", "h_{min}      = " << _minVolumeHThisTimeStep << " (volume size)");
    logInfo( "startTimeStep()", "h_{max}      = " << _maxVolumeHThisTimeStep << " (volume size)" );
    logInfo( "startTimeStep()", "lambda_{max} = " << _maxEigenvalue );
  }

  if ( isFirstGridSweepOfTimeStep() ) {
    _maxEigenvalue = 0.0;
  }

  if (
    _solverState == SolverState::Primary
    or
    _solverState == SolverState::PrimaryAfterGridInitialisation
  ) {
    logDebug("startTimeStep(...)", "Reset t and dt as state had been " << toString(_solverState));

    _minTimeStamp = _minTimeStampThisTimeStep;
    _maxTimeStamp = _maxTimeStampThisTimeStep;

    _minTimeStampThisTimeStep = std::numeric_limits<double>::max();
    _maxTimeStampThisTimeStep = std::numeric_limits<double>::min();

    _minTimeStepSize = _minTimeStepSizeThisTimeStep;
    _maxTimeStepSize = _maxTimeStepSizeThisTimeStep;

    _minTimeStepSizeThisTimeStep = std::numeric_limits<double>::max();
    _maxTimeStepSizeThisTimeStep = std::numeric_limits<double>::min();

    _minVolumeH = _minVolumeHThisTimeStep;
    _maxVolumeH = _maxVolumeHThisTimeStep;

    _maxVolumeHThisTimeStep      = 0.0;
    _minVolumeHThisTimeStep      = std::numeric_limits<double>::max()/NumberOfFiniteVolumesPerAxisPerPatch/2.0;

    _patchUpdates    = 0;

    _localMinTimeStampThisTimeStep = std::numeric_limits<double>::max();
    _localMaxTimeStampThisTimeStep = std::numeric_limits<double>::min();
  }

  if (tarch::mpi::Rank::getInstance().isGlobalMaster()) {
    logInfo("startTimeStep()", "phase " + toString(_solverState));
  }
}

void tutorials::exahype2::advection::AbstractAdvection::finishTimeStep() {
  if (_solverState==SolverState::Secondary) {
    #ifdef Parallel
    double newMinTimeStamp = _minTimeStampThisTimeStep;
    double newMaxTimeStamp = _maxTimeStampThisTimeStep;
    double newMinVolumeH   = _minVolumeHThisTimeStep;
    double newMaxVolumeH   = _maxVolumeHThisTimeStep;
    double newMinTimeStepSize = _minTimeStepSizeThisTimeStep;
    double newMaxTimeStepSize = _maxTimeStepSizeThisTimeStep;

    double newLocalMinTimeStamp = _localMinTimeStampThisTimeStep;
    double newLocalMaxTimeStamp = _localMaxTimeStampThisTimeStep;

    int newPatchUpdates = _patchUpdates;

    tarch::mpi::Rank::getInstance().allReduce(
      &newMinTimeStamp,
      &_minTimeStampThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MIN,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );
    tarch::mpi::Rank::getInstance().allReduce(
      &newMaxTimeStamp,
      &_maxTimeStampThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MAX,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

    tarch::mpi::Rank::getInstance().allReduce(
      &newMinVolumeH,
      &_minVolumeHThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MIN,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );
    tarch::mpi::Rank::getInstance().allReduce(
      &newMaxVolumeH,
      &_maxVolumeHThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MAX,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

    tarch::mpi::Rank::getInstance().allReduce(
      &newMinTimeStepSize,
      &_minTimeStepSizeThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MIN,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );
    tarch::mpi::Rank::getInstance().allReduce(
      &newMaxTimeStepSize,
      &_maxTimeStepSizeThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MAX,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

    tarch::mpi::Rank::getInstance().allReduce(
      &newLocalMinTimeStamp,
      &_localMinTimeStampThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MIN,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );
    tarch::mpi::Rank::getInstance().allReduce(
      &newLocalMaxTimeStamp,
      &_localMaxTimeStampThisTimeStep,
      1, MPI_DOUBLE,
      MPI_MAX,
      [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
      );

    tarch::mpi::Rank::getInstance().allReduce(
        &newPatchUpdates,
        &_patchUpdates,
        1, MPI_INT,
        MPI_SUM,
        [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
        );
    #endif

    if ( _minTimeStampThisTimeStep>=std::numeric_limits<double>::max()/10.0) {
      _minTimeStampThisTimeStep = 0.0;
    }
    if ( _maxTimeStampThisTimeStep>=std::numeric_limits<double>::max()/10.0 ) {
      _maxTimeStampThisTimeStep = 0.0;
    }
  }

  
  if ( isLastGridSweepOfTimeStep() ) {
    #ifdef Parallel
    double newMaxEigenvalue = _maxEigenvalue;
    tarch::mpi::Rank::getInstance().allReduce(
        &newMaxEigenvalue,
        &_maxEigenvalue,
        1,
        MPI_DOUBLE,
        MPI_MAX,
        [&]() -> void { tarch::services::ServiceRepository::getInstance().receiveDanglingMessages(); }
        );
    #endif

    if (tarch::la::smaller(_maxEigenvalue, 0.0)) {
      ::tarch::triggerNonCriticalAssertion(__FILE__, __LINE__, "_maxEigenvalue >= 0", "invalid max eigenvalue: " + std::to_string(_maxEigenvalue));
      // Keep time step size invariant
      // _admissibleTimeStepSize = _admissibleTimeStepSize;
    } else if (tarch::la::equals(_maxEigenvalue, 0.0)) {
      ::tarch::triggerNonCriticalAssertion(__FILE__, __LINE__, "_maxEigenvalue > 0", "max eigenvalue has reached zero, which means that the simulation cannot successfully continue: " + std::to_string(_maxEigenvalue));
      _admissibleTimeStepSize = 0.0;
    }
  }

    if (
      isLastGridSweepOfTimeStep()
      and
      tarch::la::greater(_maxEigenvalue, 0.0)
    ) {
      _admissibleTimeStepSize = 0.5 * _minVolumeHThisTimeStep / _maxEigenvalue;
      if (std::isnan(_admissibleTimeStepSize) or std::isinf(_admissibleTimeStepSize)) {
        ::tarch::triggerNonCriticalAssertion( __FILE__, __LINE__, "_admissibleTimeStepSize > 0", "invalid (NaN of inf) time step size: " + std::to_string(_admissibleTimeStepSize) );
      }
      if (tarch::la::smallerEquals(_admissibleTimeStepSize,0.0,1e-10) ) {
        logWarning( "finishTimeStep(...)", "degenerated time step size of " << std::to_string(_admissibleTimeStepSize) << ". Problem might be extremely stiff (and can't be solved) or there could be a bug in the eigenvalue computation");
      }
    }
}

void tutorials::exahype2::advection::AbstractAdvection::startPlottingStep(
  [[maybe_unused]] double globalMinTimeStamp,
  [[maybe_unused]] double globalMaxTimeStamp,
  [[maybe_unused]] double globalMinTimeStepSize,
  [[maybe_unused]] double globalMaxTimeStepSize
) {
  if ( _solverState == SolverState::GridInitialisation ) {
    _solverState = SolverState::PlottingInitialCondition;
  }
  else {
    assertion( mayPlot()  or ::tarch::hasNonCriticalAssertionBeenViolated() );

    _solverState = SolverState::Plotting;
  }
}

void tutorials::exahype2::advection::AbstractAdvection::finishPlottingStep() {}

std::string tutorials::exahype2::advection::AbstractAdvection::toString(SolverState state) {
  switch (state) {
    case SolverState::GridConstruction:
      return "grid-construction";
    case SolverState::GridInitialisation:
      return "grid-initialisation";
    case SolverState::Primary:
      return "primary";
    case SolverState::Secondary:
      return "secondary";
    case SolverState::PlottingInitialCondition:
      return "plotting-initial-condition";
    case SolverState::PrimaryAfterGridInitialisation:
      return "primary-after-grid-initialisation";
    case SolverState::Plotting:
      return "plotting";
  }
  return "<undef>";
}

bool tutorials::exahype2::advection::AbstractAdvection::isFirstGridSweepOfTimeStep() const {
  return _solverState != SolverState::Secondary;
}

bool tutorials::exahype2::advection::AbstractAdvection::isLastGridSweepOfTimeStep() const {
  return _solverState == SolverState::Secondary;
}

bool tutorials::exahype2::advection::AbstractAdvection::mayPlot() const {
  return _solverState == SolverState::Secondary;
}


bool tutorials::exahype2::advection::AbstractAdvection::patchCanUseStatelessPDETerms(
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& patchCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& patchH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt
) const {
  return true;
}


void tutorials::exahype2::advection::AbstractAdvection::startSimulation() {
  #if defined(UseSmartMPI)
  tarch::multicore::registerSmartMPITask(
    tasks::AdvectionEnclaveTask::getEnclaveTaskTypeId(),
    [](smartmpi::ReceiverCallType type, int rank, int tag, MPI_Comm communicator) -> smartmpi::Task* {
      if (type==smartmpi::ReceiverCallType::ReceiveTask) {
        return tasks::AdvectionEnclaveTask::receiveTask( rank, tag, communicator );
      } else if (type==smartmpi::ReceiverCallType::ReceivedTaskOutcomeForFowarding) {
        static constexpr bool isForwarding = true;
        return tasks::AdvectionEnclaveTask::receiveOutcome( rank, tag, communicator, isForwarding);
      } else {
        assert(type==smartmpi::ReceiverCallType::ReceiveOutcome);
        static constexpr bool isForwarding = false;
        return tasks::AdvectionEnclaveTask::receiveOutcome( rank, tag, communicator, isForwarding );
      }
    }
  );
  #endif
}


void tutorials::exahype2::advection::AbstractAdvection::finishSimulation() {}




double tutorials::exahype2::advection::AbstractAdvection::maxEigenvalue(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] int                                          normal
) {
  assertion(normal >= 0);
assertion(normal < Dimensions);
[[maybe_unused]] const double v_0 = Q[0];
nonCriticalAssertion(Q[0] == Q[0]);
assertion(!std::isnan(v_0));
[[maybe_unused]] const double v_1 = Q[1];
nonCriticalAssertion(Q[1] == Q[1]);
assertion(!std::isnan(v_1));
const double x_0 = faceCentre(0);
const double x_1 = faceCentre(1);
const double h_0 = volumeH(0);
const double h_1 = volumeH(1);
double lambda[2];
switch (normal) {
  case 0:
lambda[0] = 1.0;
assertion(!std::isnan(lambda[0]));
lambda[1] = 1.0;
assertion(!std::isnan(lambda[1]));
  break;
  case 1:
lambda[0] = 1.0;
assertion(!std::isnan(lambda[0]));
lambda[1] = 1.0;
assertion(!std::isnan(lambda[1]));
  break;
}
double result = 0.0;
result = std::max( result, std::abs(lambda[0]) );
result = std::max( result, std::abs(lambda[1]) );
return result;

}



void tutorials::exahype2::advection::AbstractAdvection::flux(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] int                                          normal,
  [[maybe_unused]] double* __restrict__                         F // F[2]
) {
  assertion(normal >= 0);
assertion(normal < Dimensions);
[[maybe_unused]] const double v_0 = Q[0];
nonCriticalAssertion(Q[0] == Q[0]);
assertion(!std::isnan(v_0));
[[maybe_unused]] const double v_1 = Q[1];
nonCriticalAssertion(Q[1] == Q[1]);
assertion(!std::isnan(v_1));
const double x_0 = faceCentre(0);
const double x_1 = faceCentre(1);
const double h_0 = volumeH(0);
const double h_1 = volumeH(1);
switch( normal ) {
  case 0:
F[0] = v_0;
assertion(!std::isnan(F[0]));
nonCriticalAssertion(F[0] == F[0]);
F[1] = 0;
assertion(!std::isnan(F[1]));
nonCriticalAssertion(F[1] == F[1]);
  break;
  case 1:
F[0] = 0;
assertion(!std::isnan(F[0]));
nonCriticalAssertion(F[0] == F[0]);
F[1] = v_1;
assertion(!std::isnan(F[1]));
nonCriticalAssertion(F[1] == F[1]);
  break;
}

}







#if defined(GPUOffloadingOMP)
#pragma omp declare target
#endif
//#if !defined(GPUOffloadingSYCL)
GPUCallableMethod double tutorials::exahype2::advection::AbstractAdvection::maxEigenvalue(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] int                                          normal,
  Offloadable
) {
  assertion(normal >= 0);
assertion(normal < Dimensions);
[[maybe_unused]] const double v_0 = Q[0];
nonCriticalAssertion(Q[0] == Q[0]);
assertion(!std::isnan(v_0));
[[maybe_unused]] const double v_1 = Q[1];
nonCriticalAssertion(Q[1] == Q[1]);
assertion(!std::isnan(v_1));
const double x_0 = faceCentre(0);
const double x_1 = faceCentre(1);
const double h_0 = volumeH(0);
const double h_1 = volumeH(1);
double lambda[2];
switch (normal) {
  case 0:
lambda[0] = 1.0;
assertion(!std::isnan(lambda[0]));
lambda[1] = 1.0;
assertion(!std::isnan(lambda[1]));
  break;
  case 1:
lambda[0] = 1.0;
assertion(!std::isnan(lambda[0]));
lambda[1] = 1.0;
assertion(!std::isnan(lambda[1]));
  break;
}
double result = 0.0;
result = std::max( result, std::abs(lambda[0]) );
result = std::max( result, std::abs(lambda[1]) );
return result;
;
}
//#endif
#if defined(GPUOffloadingOMP)
#pragma omp end declare target
#endif



#if defined(GPUOffloadingOMP)
#pragma omp declare target
#endif
//#if !defined(GPUOffloadingSYCL)
GPUCallableMethod void tutorials::exahype2::advection::AbstractAdvection::flux(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] int                                          normal,
  [[maybe_unused]] double* __restrict__                         F, // F[2]
  Offloadable
) {
  
  assertion(normal >= 0);
assertion(normal < Dimensions);
[[maybe_unused]] const double v_0 = Q[0];
nonCriticalAssertion(Q[0] == Q[0]);
assertion(!std::isnan(v_0));
[[maybe_unused]] const double v_1 = Q[1];
nonCriticalAssertion(Q[1] == Q[1]);
assertion(!std::isnan(v_1));
const double x_0 = faceCentre(0);
const double x_1 = faceCentre(1);
const double h_0 = volumeH(0);
const double h_1 = volumeH(1);
switch( normal ) {
  case 0:
F[0] = v_0;
assertion(!std::isnan(F[0]));
nonCriticalAssertion(F[0] == F[0]);
F[1] = 0;
assertion(!std::isnan(F[1]));
nonCriticalAssertion(F[1] == F[1]);
  break;
  case 1:
F[0] = 0;
assertion(!std::isnan(F[0]));
nonCriticalAssertion(F[0] == F[0]);
F[1] = v_1;
assertion(!std::isnan(F[1]));
nonCriticalAssertion(F[1] == F[1]);
  break;
}

  
}
//#endif
#if defined(GPUOffloadingOMP)
#pragma omp end declare target
#endif



#if defined(GPUOffloadingOMP)
#pragma omp declare target
#endif
GPUCallableMethod void tutorials::exahype2::advection::AbstractAdvection::nonconservativeProduct(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const double* __restrict__                   deltaQ, // deltaQ[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& faceCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] int                                          normal,
  [[maybe_unused]] double* __restrict__                         BTimesDeltaQ, // BTimesDeltaQ[2]
  [[maybe_unused]] Offloadable
) {
  
  tarch::gpuAbort();
  
}
#if defined(GPUOffloadingOMP)
#pragma omp end declare target
#endif



#if defined(GPUOffloadingOMP)
#pragma omp declare target
#endif
GPUCallableMethod void tutorials::exahype2::advection::AbstractAdvection::sourceTerm(
  [[maybe_unused]] const double* __restrict__                   Q, // Q[2+0]
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeCentre,
  [[maybe_unused]] const tarch::la::Vector<Dimensions, double>& volumeH,
  [[maybe_unused]] double                                       t,
  [[maybe_unused]] double                                       dt,
  [[maybe_unused]] double* __restrict__                         S, // S[2]
  [[maybe_unused]] Offloadable
) {
  
  tarch::gpuAbort();
  
}
#if defined(GPUOffloadingOMP)
#pragma omp end declare target
#endif

void tutorials::exahype2::advection::AbstractAdvection::setMaxEigenvalue( double eigenvalue ) {
  if ( tarch::la::greater( eigenvalue, 0.0 ) ) {
    tarch::multicore::Lock lock(_semaphore);
    _maxEigenvalue = std::max(_maxEigenvalue,eigenvalue);
  }
}    


double tutorials::exahype2::advection::AbstractAdvection::getAdmissibleTimeStepSize() const {
  return _admissibleTimeStepSize;
}
    